'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */

// import {Matrix4} from 'luma.gl';

exports.getUniformsFromViewport = getUniformsFromViewport;

var _glMatrix = require('gl-matrix');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function fp64ify(a) {
  var hiPart = Math.fround(a);
  var loPart = a - hiPart;
  return [hiPart, loPart];
}

// To quickly set a vector to zero
var ZERO_VECTOR = [0, 0, 0, 0];
// 4x4 matrix that drops 4th component of vector
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];

// The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,
// has lower performance but provides error checking.
// Uncomment when debugging
function calculateMatrixAndOffset(_ref) {
  var projectionMode = _ref.projectionMode,
      positionOrigin = _ref.positionOrigin,
      viewport = _ref.viewport,
      modelMatrix = _ref.modelMatrix;
  var viewMatrixUncentered = viewport.viewMatrixUncentered,
      viewMatrix = viewport.viewMatrix,
      projectionMatrix = viewport.projectionMatrix,
      viewProjectionMatrix = viewport.viewProjectionMatrix;


  var projectionCenter = void 0;
  var modelViewMatrix = void 0;

  switch (projectionMode) {

    case _constants.COORDINATE_SYSTEM.IDENTITY:
    case _constants.COORDINATE_SYSTEM.LNGLAT:
      projectionCenter = ZERO_VECTOR;
      // modelViewMatrix = new Matrix4(viewMatrix);
      modelViewMatrix = _glMatrix.mat4.copy([], viewMatrix);
      break;

    // TODO: make lighitng work for meter offset mode
    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
      // Calculate transformed projectionCenter (in 64 bit precision)
      // This is the key to offset mode precision (avoids doing this
      // addition in 32 bit precision)
      var positionPixels = viewport.projectFlat(positionOrigin);
      // projectionCenter = new Matrix4(viewProjectionMatrix)
      //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);
      projectionCenter = _glMatrix.vec4.transformMat4([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix);

      // Always apply uncentered projection matrix if available (shader adds center)
      // Zero out 4th coordinate ("after" model matrix) - avoids further translations
      // modelViewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)
      //   .multiplyRight(VECTOR_TO_POINT_MATRIX);
      modelViewMatrix = _glMatrix.mat4.multiply([], viewMatrixUncentered || viewMatrix, VECTOR_TO_POINT_MATRIX);
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  var viewMatrixInv = _glMatrix.mat4.invert([], modelViewMatrix) || modelViewMatrix;

  if (modelMatrix) {
    // Apply model matrix if supplied
    // modelViewMatrix.multiplyRight(modelMatrix);
    _glMatrix.mat4.multiply(modelViewMatrix, modelViewMatrix, modelMatrix);
  }

  // const modelViewProjectionMatrix = new Matrix4(projectionMatrix).multiplyRight(modelViewMatrix);
  var modelViewProjectionMatrix = _glMatrix.mat4.multiply([], projectionMatrix, modelViewMatrix);
  var cameraPos = [viewMatrixInv[12], viewMatrixInv[13], viewMatrixInv[14]];

  return {
    modelViewMatrix: modelViewMatrix,
    modelViewProjectionMatrix: modelViewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPos: cameraPos
  };
}

/**
 * Returns uniforms for shaders based on current projection
 * includes: projection matrix suitable for shaders
 *
 * TODO - Ensure this works with any viewport, not just WebMercatorViewports
 *
 * @param {WebMercatorViewport} viewport -
 * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
 */
function getUniformsFromViewport(viewport) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$modelMatrix = _ref2.modelMatrix,
      modelMatrix = _ref2$modelMatrix === undefined ? null : _ref2$modelMatrix,
      _ref2$projectionMode = _ref2.projectionMode,
      projectionMode = _ref2$projectionMode === undefined ? _constants.COORDINATE_SYSTEM.LNGLAT : _ref2$projectionMode,
      _ref2$positionOrigin = _ref2.positionOrigin,
      positionOrigin = _ref2$positionOrigin === undefined ? [0, 0] : _ref2$positionOrigin;

  (0, _assert2.default)(viewport.scale, 'Viewport scale missing');

  var _calculateMatrixAndOf = calculateMatrixAndOffset({ projectionMode: projectionMode, positionOrigin: positionOrigin, modelMatrix: modelMatrix, viewport: viewport }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      modelViewMatrix = _calculateMatrixAndOf.modelViewMatrix,
      modelViewProjectionMatrix = _calculateMatrixAndOf.modelViewProjectionMatrix,
      cameraPos = _calculateMatrixAndOf.cameraPos;

  (0, _assert2.default)(modelViewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');

  // Calculate projection pixels per unit
  var projectionPixelsPerUnit = viewport.getDistanceScales().pixelsPerMeter;
  (0, _assert2.default)(projectionPixelsPerUnit, 'Viewport missing pixelsPerMeter');

  // calculate WebGL matrices

  // Convert to Float32
  var glProjectionMatrix = new Float32Array(modelViewProjectionMatrix);

  // "Float64Array"
  // Transpose the projection matrix to column major for GLSL.
  var glProjectionMatrixFP64 = new Float32Array(32);
  for (var i = 0; i < 4; ++i) {
    for (var j = 0; j < 4; ++j) {
      var _fp64ify = fp64ify(modelViewProjectionMatrix[j * 4 + i]);

      var _fp64ify2 = _slicedToArray(_fp64ify, 2);

      glProjectionMatrixFP64[(i * 4 + j) * 2] = _fp64ify2[0];
      glProjectionMatrixFP64[(i * 4 + j) * 2 + 1] = _fp64ify2[1];
    }
  }

  var devicePixelRatio = window && window.devicePixelRatio || 1;

  return {
    // Projection mode values
    projectionMode: projectionMode,
    projectionCenter: projectionCenter,

    // modelMatrix: modelMatrix || new Matrix4().identity(),
    modelViewMatrix: new Float32Array(modelViewMatrix),

    // Screen size
    viewportSize: [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio],
    devicePixelRatio: devicePixelRatio,

    // Main projection matrices
    projectionMatrix: glProjectionMatrix,
    projectionMatrixUncentered: glProjectionMatrix,
    projectionFP64: glProjectionMatrixFP64,
    projectionPixelsPerUnit: projectionPixelsPerUnit,

    // This is the mercator scale (2 ** zoom)
    projectionScale: viewport.scale,

    // Deprecated?
    projectionScaleFP64: fp64ify(viewport.scale),

    // This is for lighting calculations
    cameraPos: new Float32Array(cameraPos)

  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdmlld3BvcnQtdW5pZm9ybXMuanMiXSwibmFtZXMiOlsiZ2V0VW5pZm9ybXNGcm9tVmlld3BvcnQiLCJmcDY0aWZ5IiwiYSIsImhpUGFydCIsIk1hdGgiLCJmcm91bmQiLCJsb1BhcnQiLCJaRVJPX1ZFQ1RPUiIsIlZFQ1RPUl9UT19QT0lOVF9NQVRSSVgiLCJjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQiLCJwcm9qZWN0aW9uTW9kZSIsInBvc2l0aW9uT3JpZ2luIiwidmlld3BvcnQiLCJtb2RlbE1hdHJpeCIsInZpZXdNYXRyaXhVbmNlbnRlcmVkIiwidmlld01hdHJpeCIsInByb2plY3Rpb25NYXRyaXgiLCJ2aWV3UHJvamVjdGlvbk1hdHJpeCIsInByb2plY3Rpb25DZW50ZXIiLCJtb2RlbFZpZXdNYXRyaXgiLCJJREVOVElUWSIsIkxOR0xBVCIsImNvcHkiLCJNRVRFUl9PRkZTRVRTIiwicG9zaXRpb25QaXhlbHMiLCJwcm9qZWN0RmxhdCIsInRyYW5zZm9ybU1hdDQiLCJtdWx0aXBseSIsIkVycm9yIiwidmlld01hdHJpeEludiIsImludmVydCIsIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgiLCJjYW1lcmFQb3MiLCJzY2FsZSIsInByb2plY3Rpb25QaXhlbHNQZXJVbml0IiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJwaXhlbHNQZXJNZXRlciIsImdsUHJvamVjdGlvbk1hdHJpeCIsIkZsb2F0MzJBcnJheSIsImdsUHJvamVjdGlvbk1hdHJpeEZQNjQiLCJpIiwiaiIsImRldmljZVBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJ2aWV3cG9ydFNpemUiLCJ3aWR0aCIsImhlaWdodCIsInByb2plY3Rpb25NYXRyaXhVbmNlbnRlcmVkIiwicHJvamVjdGlvbkZQNjQiLCJwcm9qZWN0aW9uU2NhbGUiLCJwcm9qZWN0aW9uU2NhbGVGUDY0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7eXBCQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUl0QnhDLFFBQVE4QiwwQkFBMEJVLElBQUksQ0FBSixHQUFRRCxDQUFsQyxDQUFSLENBSnNCOztBQUFBOztBQUV4QkQsNkJBQXVCLENBQUNDLElBQUksQ0FBSixHQUFRQyxDQUFULElBQWMsQ0FBckMsQ0FGd0I7QUFHeEJGLDZCQUF1QixDQUFDQyxJQUFJLENBQUosR0FBUUMsQ0FBVCxJQUFjLENBQWQsR0FBa0IsQ0FBekMsQ0FId0I7QUFLM0I7QUFDRjs7QUFFRCxNQUFNQyxtQkFBb0JDLFVBQVVBLE9BQU9ELGdCQUFsQixJQUF1QyxDQUFoRTs7QUFFQSxTQUFPO0FBQ0w7QUFDQWhDLGtDQUZLO0FBR0xRLHNDQUhLOztBQUtMO0FBQ0FDLHFCQUFpQixJQUFJbUIsWUFBSixDQUFpQm5CLGVBQWpCLENBTlo7O0FBUUw7QUFDQXlCLGtCQUFjLENBQUNoQyxTQUFTaUMsS0FBVCxHQUFpQkgsZ0JBQWxCLEVBQW9DOUIsU0FBU2tDLE1BQVQsR0FBa0JKLGdCQUF0RCxDQVRUO0FBVUxBLHNDQVZLOztBQVlMO0FBQ0ExQixzQkFBa0JxQixrQkFiYjtBQWNMVSxnQ0FBNEJWLGtCQWR2QjtBQWVMVyxvQkFBZ0JULHNCQWZYO0FBZ0JMTCxvREFoQks7O0FBa0JMO0FBQ0FlLHFCQUFpQnJDLFNBQVNxQixLQW5CckI7O0FBcUJMO0FBQ0FpQix5QkFBcUJqRCxRQUFRVyxTQUFTcUIsS0FBakIsQ0F0QmhCOztBQXdCTDtBQUNBRCxlQUFXLElBQUlNLFlBQUosQ0FBaUJOLFNBQWpCOztBQXpCTixHQUFQO0FBNEJEIiwiZmlsZSI6InZpZXdwb3J0LXVuaWZvcm1zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7bWF0NCwgdmVjNH0gZnJvbSAnZ2wtbWF0cml4Jztcbi8vIGltcG9ydCB7TWF0cml4NH0gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4vY29uc3RhbnRzJztcblxuZnVuY3Rpb24gZnA2NGlmeShhKSB7XG4gIGNvbnN0IGhpUGFydCA9IE1hdGguZnJvdW5kKGEpO1xuICBjb25zdCBsb1BhcnQgPSBhIC0gaGlQYXJ0O1xuICByZXR1cm4gW2hpUGFydCwgbG9QYXJ0XTtcbn1cblxuLy8gVG8gcXVpY2tseSBzZXQgYSB2ZWN0b3IgdG8gemVyb1xuY29uc3QgWkVST19WRUNUT1IgPSBbMCwgMCwgMCwgMF07XG4vLyA0eDQgbWF0cml4IHRoYXQgZHJvcHMgNHRoIGNvbXBvbmVudCBvZiB2ZWN0b3JcbmNvbnN0IFZFQ1RPUl9UT19QT0lOVF9NQVRSSVggPSBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMF07XG5cbi8vIFRoZSBjb2RlIHRoYXQgdXRpbGl6ZXMgTWF0cml4NCBkb2VzIHRoZSBzYW1lIGNhbGN1bGF0aW9uIGFzIHRoZWlyIG1hdDQgY291bnRlcnBhcnRzLFxuLy8gaGFzIGxvd2VyIHBlcmZvcm1hbmNlIGJ1dCBwcm92aWRlcyBlcnJvciBjaGVja2luZy5cbi8vIFVuY29tbWVudCB3aGVuIGRlYnVnZ2luZ1xuZnVuY3Rpb24gY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0KHtcbiAgcHJvamVjdGlvbk1vZGUsXG4gIHBvc2l0aW9uT3JpZ2luLFxuICB2aWV3cG9ydCxcbiAgbW9kZWxNYXRyaXhcbn0pIHtcbiAgY29uc3Qge3ZpZXdNYXRyaXhVbmNlbnRlcmVkLCB2aWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4LCB2aWV3UHJvamVjdGlvbk1hdHJpeH0gPSB2aWV3cG9ydDtcblxuICBsZXQgcHJvamVjdGlvbkNlbnRlcjtcbiAgbGV0IG1vZGVsVmlld01hdHJpeDtcblxuICBzd2l0Y2ggKHByb2plY3Rpb25Nb2RlKSB7XG5cbiAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5JREVOVElUWTpcbiAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQ6XG4gICAgcHJvamVjdGlvbkNlbnRlciA9IFpFUk9fVkVDVE9SO1xuICAgIC8vIG1vZGVsVmlld01hdHJpeCA9IG5ldyBNYXRyaXg0KHZpZXdNYXRyaXgpO1xuICAgIG1vZGVsVmlld01hdHJpeCA9IG1hdDQuY29weShbXSwgdmlld01hdHJpeCk7XG4gICAgYnJlYWs7XG5cbiAgLy8gVE9ETzogbWFrZSBsaWdoaXRuZyB3b3JrIGZvciBtZXRlciBvZmZzZXQgbW9kZVxuICBjYXNlIENPT1JESU5BVEVfU1lTVEVNLk1FVEVSX09GRlNFVFM6XG4gICAgLy8gQ2FsY3VsYXRlIHRyYW5zZm9ybWVkIHByb2plY3Rpb25DZW50ZXIgKGluIDY0IGJpdCBwcmVjaXNpb24pXG4gICAgLy8gVGhpcyBpcyB0aGUga2V5IHRvIG9mZnNldCBtb2RlIHByZWNpc2lvbiAoYXZvaWRzIGRvaW5nIHRoaXNcbiAgICAvLyBhZGRpdGlvbiBpbiAzMiBiaXQgcHJlY2lzaW9uKVxuICAgIGNvbnN0IHBvc2l0aW9uUGl4ZWxzID0gdmlld3BvcnQucHJvamVjdEZsYXQocG9zaXRpb25PcmlnaW4pO1xuICAgIC8vIHByb2plY3Rpb25DZW50ZXIgPSBuZXcgTWF0cml4NCh2aWV3UHJvamVjdGlvbk1hdHJpeClcbiAgICAvLyAgIC50cmFuc2Zvcm1WZWN0b3IoW3Bvc2l0aW9uUGl4ZWxzWzBdLCBwb3NpdGlvblBpeGVsc1sxXSwgMC4wLCAxLjBdKTtcbiAgICBwcm9qZWN0aW9uQ2VudGVyID0gdmVjNC50cmFuc2Zvcm1NYXQ0KFtdLFxuICAgICAgW3Bvc2l0aW9uUGl4ZWxzWzBdLCBwb3NpdGlvblBpeGVsc1sxXSwgMC4wLCAxLjBdLFxuICAgICAgdmlld1Byb2plY3Rpb25NYXRyaXgpO1xuXG4gICAgLy8gQWx3YXlzIGFwcGx5IHVuY2VudGVyZWQgcHJvamVjdGlvbiBtYXRyaXggaWYgYXZhaWxhYmxlIChzaGFkZXIgYWRkcyBjZW50ZXIpXG4gICAgLy8gWmVybyBvdXQgNHRoIGNvb3JkaW5hdGUgKFwiYWZ0ZXJcIiBtb2RlbCBtYXRyaXgpIC0gYXZvaWRzIGZ1cnRoZXIgdHJhbnNsYXRpb25zXG4gICAgLy8gbW9kZWxWaWV3TWF0cml4ID0gbmV3IE1hdHJpeDQodmlld01hdHJpeFVuY2VudGVyZWQgfHwgdmlld01hdHJpeClcbiAgICAvLyAgIC5tdWx0aXBseVJpZ2h0KFZFQ1RPUl9UT19QT0lOVF9NQVRSSVgpO1xuICAgIG1vZGVsVmlld01hdHJpeCA9IG1hdDQubXVsdGlwbHkoW10sIHZpZXdNYXRyaXhVbmNlbnRlcmVkIHx8IHZpZXdNYXRyaXgsIFZFQ1RPUl9UT19QT0lOVF9NQVRSSVgpO1xuICAgIGJyZWFrO1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb2plY3Rpb24gbW9kZScpO1xuICB9XG5cbiAgY29uc3Qgdmlld01hdHJpeEludiA9IG1hdDQuaW52ZXJ0KFtdLCBtb2RlbFZpZXdNYXRyaXgpIHx8IG1vZGVsVmlld01hdHJpeDtcblxuICBpZiAobW9kZWxNYXRyaXgpIHtcbiAgICAvLyBBcHBseSBtb2RlbCBtYXRyaXggaWYgc3VwcGxpZWRcbiAgICAvLyBtb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlSaWdodChtb2RlbE1hdHJpeCk7XG4gICAgbWF0NC5tdWx0aXBseShtb2RlbFZpZXdNYXRyaXgsIG1vZGVsVmlld01hdHJpeCwgbW9kZWxNYXRyaXgpO1xuICB9XG5cbiAgLy8gY29uc3QgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KHByb2plY3Rpb25NYXRyaXgpLm11bHRpcGx5UmlnaHQobW9kZWxWaWV3TWF0cml4KTtcbiAgY29uc3QgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG1hdDQubXVsdGlwbHkoW10sIHByb2plY3Rpb25NYXRyaXgsIG1vZGVsVmlld01hdHJpeCk7XG4gIGNvbnN0IGNhbWVyYVBvcyA9IFt2aWV3TWF0cml4SW52WzEyXSwgdmlld01hdHJpeEludlsxM10sIHZpZXdNYXRyaXhJbnZbMTRdXTtcblxuICByZXR1cm4ge1xuICAgIG1vZGVsVmlld01hdHJpeCxcbiAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25DZW50ZXIsXG4gICAgY2FtZXJhUG9zXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB1bmlmb3JtcyBmb3Igc2hhZGVycyBiYXNlZCBvbiBjdXJyZW50IHByb2plY3Rpb25cbiAqIGluY2x1ZGVzOiBwcm9qZWN0aW9uIG1hdHJpeCBzdWl0YWJsZSBmb3Igc2hhZGVyc1xuICpcbiAqIFRPRE8gLSBFbnN1cmUgdGhpcyB3b3JrcyB3aXRoIGFueSB2aWV3cG9ydCwgbm90IGp1c3QgV2ViTWVyY2F0b3JWaWV3cG9ydHNcbiAqXG4gKiBAcGFyYW0ge1dlYk1lcmNhdG9yVmlld3BvcnR9IHZpZXdwb3J0IC1cbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gLSA0eDQgcHJvamVjdGlvbiBtYXRyaXggdGhhdCBjYW4gYmUgdXNlZCBpbiBzaGFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCh2aWV3cG9ydCwge1xuICBtb2RlbE1hdHJpeCA9IG51bGwsXG4gIHByb2plY3Rpb25Nb2RlID0gQ09PUkRJTkFURV9TWVNURU0uTE5HTEFULFxuICBwb3NpdGlvbk9yaWdpbiA9IFswLCAwXVxufSA9IHt9KSB7XG4gIGFzc2VydCh2aWV3cG9ydC5zY2FsZSwgJ1ZpZXdwb3J0IHNjYWxlIG1pc3NpbmcnKTtcblxuICBjb25zdCB7cHJvamVjdGlvbkNlbnRlciwgbW9kZWxWaWV3TWF0cml4LCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LCBjYW1lcmFQb3N9ID1cbiAgICBjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQoe3Byb2plY3Rpb25Nb2RlLCBwb3NpdGlvbk9yaWdpbiwgbW9kZWxNYXRyaXgsIHZpZXdwb3J0fSk7XG5cbiAgYXNzZXJ0KG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsICdWaWV3cG9ydCBtaXNzaW5nIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgnKTtcblxuICAvLyBDYWxjdWxhdGUgcHJvamVjdGlvbiBwaXhlbHMgcGVyIHVuaXRcbiAgY29uc3QgcHJvamVjdGlvblBpeGVsc1BlclVuaXQgPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcygpLnBpeGVsc1Blck1ldGVyO1xuICBhc3NlcnQocHJvamVjdGlvblBpeGVsc1BlclVuaXQsICdWaWV3cG9ydCBtaXNzaW5nIHBpeGVsc1Blck1ldGVyJyk7XG5cbiAgLy8gY2FsY3VsYXRlIFdlYkdMIG1hdHJpY2VzXG5cbiAgLy8gQ29udmVydCB0byBGbG9hdDMyXG4gIGNvbnN0IGdsUHJvamVjdGlvbk1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgLy8gXCJGbG9hdDY0QXJyYXlcIlxuICAvLyBUcmFuc3Bvc2UgdGhlIHByb2plY3Rpb24gbWF0cml4IHRvIGNvbHVtbiBtYWpvciBmb3IgR0xTTC5cbiAgY29uc3QgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NCA9IG5ldyBGbG9hdDMyQXJyYXkoMzIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgKytqKSB7XG4gICAgICBbXG4gICAgICAgIGdsUHJvamVjdGlvbk1hdHJpeEZQNjRbKGkgKiA0ICsgaikgKiAyXSxcbiAgICAgICAgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NFsoaSAqIDQgKyBqKSAqIDIgKyAxXVxuICAgICAgXSA9IGZwNjRpZnkobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFtqICogNCArIGldKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gKHdpbmRvdyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMTtcblxuICByZXR1cm4ge1xuICAgIC8vIFByb2plY3Rpb24gbW9kZSB2YWx1ZXNcbiAgICBwcm9qZWN0aW9uTW9kZSxcbiAgICBwcm9qZWN0aW9uQ2VudGVyLFxuXG4gICAgLy8gbW9kZWxNYXRyaXg6IG1vZGVsTWF0cml4IHx8IG5ldyBNYXRyaXg0KCkuaWRlbnRpdHkoKSxcbiAgICBtb2RlbFZpZXdNYXRyaXg6IG5ldyBGbG9hdDMyQXJyYXkobW9kZWxWaWV3TWF0cml4KSxcblxuICAgIC8vIFNjcmVlbiBzaXplXG4gICAgdmlld3BvcnRTaXplOiBbdmlld3BvcnQud2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvLCB2aWV3cG9ydC5oZWlnaHQgKiBkZXZpY2VQaXhlbFJhdGlvXSxcbiAgICBkZXZpY2VQaXhlbFJhdGlvLFxuXG4gICAgLy8gTWFpbiBwcm9qZWN0aW9uIG1hdHJpY2VzXG4gICAgcHJvamVjdGlvbk1hdHJpeDogZ2xQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25NYXRyaXhVbmNlbnRlcmVkOiBnbFByb2plY3Rpb25NYXRyaXgsXG4gICAgcHJvamVjdGlvbkZQNjQ6IGdsUHJvamVjdGlvbk1hdHJpeEZQNjQsXG4gICAgcHJvamVjdGlvblBpeGVsc1BlclVuaXQsXG5cbiAgICAvLyBUaGlzIGlzIHRoZSBtZXJjYXRvciBzY2FsZSAoMiAqKiB6b29tKVxuICAgIHByb2plY3Rpb25TY2FsZTogdmlld3BvcnQuc2NhbGUsXG5cbiAgICAvLyBEZXByZWNhdGVkP1xuICAgIHByb2plY3Rpb25TY2FsZUZQNjQ6IGZwNjRpZnkodmlld3BvcnQuc2NhbGUpLFxuXG4gICAgLy8gVGhpcyBpcyBmb3IgbGlnaHRpbmcgY2FsY3VsYXRpb25zXG4gICAgY2FtZXJhUG9zOiBuZXcgRmxvYXQzMkFycmF5KGNhbWVyYVBvcylcblxuICB9O1xufVxuIl19