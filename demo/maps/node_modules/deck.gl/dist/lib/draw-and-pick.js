'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawLayers = drawLayers;
exports.pickLayers = pickLayers;

var _luma = require('luma.gl');

var _viewportUniforms = require('./viewport-uniforms');

var _utils = require('./utils');

var EMPTY_PIXEL = new Uint8Array(4); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */

var renderCount = 0;

function drawLayers(_ref) {
  var layers = _ref.layers,
      pass = _ref.pass;

  _utils.log.log(3, 'DRAWING ' + layers.length + ' layers');

  // render layers in normal colors
  var visibleCount = 0;
  // render layers in normal colors
  layers.forEach(function (layer, layerIndex) {
    if (!layer.isComposite && layer.props.visible) {
      layer.drawLayer({
        uniforms: Object.assign({ renderPickingBuffer: 0, pickingEnabled: 0 }, layer.context.uniforms, (0, _viewportUniforms.getUniformsFromViewport)(layer.context.viewport, layer.props), { layerIndex: layerIndex })
      });
      visibleCount++;
    }
  });

  _utils.log.log(3, 'RENDER PASS ' + pass + ': ' + renderCount++ + '\n    ' + visibleCount + ' visible, ' + layers.length + ' total');
}

/* eslint-disable max-depth, max-statements */
function pickLayers(gl, _ref2) {
  var layers = _ref2.layers,
      pickingFBO = _ref2.pickingFBO,
      _ref2$uniforms = _ref2.uniforms,
      uniforms = _ref2$uniforms === undefined ? {} : _ref2$uniforms,
      x = _ref2.x,
      y = _ref2.y,
      viewport = _ref2.viewport,
      mode = _ref2.mode,
      lastPickedInfo = _ref2.lastPickedInfo;


  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceX = x * pixelRatio;
  var deviceY = gl.canvas.height - y * pixelRatio;

  // TODO - just return glContextWithState once luma updates
  var unhandledPickInfos = [];

  // Make sure we clear scissor test and fbo bindings in case of exceptions
  // We are only interested in one pixel, no need to render anything else
  (0, _luma.glContextWithState)(gl, {
    frameBuffer: pickingFBO,
    framebuffer: pickingFBO,
    scissorTest: { x: deviceX, y: deviceY, w: 1, h: 1 }
  }, function () {

    // Picking process start
    // Clear the frame buffer
    gl.clear(_luma.GL.COLOR_BUFFER_BIT | _luma.GL.DEPTH_BUFFER_BIT);
    // Save current blend settings
    var oldBlendMode = (0, _utils.getBlendMode)(gl);
    // Set blend mode for picking
    // always overwrite existing pixel with [r,g,b,layerIndex]
    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO);
    gl.blendEquation(gl.FUNC_ADD);

    // Render all pickable layers in picking colors
    layers.forEach(function (layer, layerIndex) {
      if (!layer.isComposite && layer.props.visible && layer.props.pickable) {

        // Encode layerIndex with alpha
        gl.blendColor(0, 0, 0, (layerIndex + 1) / 255);

        layer.drawLayer({
          uniforms: Object.assign({ renderPickingBuffer: 1, pickingEnabled: 1 }, layer.context.uniforms, (0, _viewportUniforms.getUniformsFromViewport)(layer.context.viewport, layer.props), { layerIndex: layerIndex })
        });
      }
    });

    // Read color in the central pixel, to be mapped with picking colors
    var pickedColor = new Uint8Array(4);
    gl.readPixels(deviceX, deviceY, 1, 1, _luma.GL.RGBA, _luma.GL.UNSIGNED_BYTE, pickedColor);

    // restore blend mode
    (0, _utils.setBlendMode)(gl, oldBlendMode);
    // Picking process end

    // Process picked info start
    // Decode picked color
    var pickedLayerIndex = pickedColor[3] - 1;
    var pickedLayer = pickedLayerIndex >= 0 ? layers[pickedLayerIndex] : null;
    var pickedObjectIndex = pickedLayer ? pickedLayer.decodePickingColor(pickedColor) : -1;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;
    var affectedLayers = pickedLayer ? [pickedLayer] : [];

    if (mode === 'hover') {
      // only invoke onHover events if picked object has changed
      var lastPickedObjectIndex = lastPickedInfo.index;
      var lastPickedLayerId = lastPickedInfo.layerId;

      if (pickedLayerId === lastPickedLayerId && pickedObjectIndex === lastPickedObjectIndex) {
        // picked object did not change, no need to proceed
        return;
      }

      if (pickedLayerId !== lastPickedLayerId) {
        // We cannot store a ref to lastPickedLayer in the context because
        // the state of an outdated layer is no longer valid
        // and the props may have changed
        var lastPickedLayer = layers.find(function (l) {
          return l.props.id === lastPickedLayerId;
        });
        if (lastPickedLayer) {
          // Let leave event fire before enter event
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      // Update layer manager context
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
    }

    var baseInfo = createInfo([x, y], viewport);
    baseInfo.devicePixel = [deviceX, deviceY];
    baseInfo.pixelRatio = pixelRatio;

    // Use a Map to store all picking infos.
    // The following two forEach loops are the result of
    // https://github.com/uber/deck.gl/issues/443
    // Please be very careful when changing this pattern
    var infos = new Map();

    affectedLayers.forEach(function (layer) {
      var info = Object.assign({}, baseInfo);

      if (layer === pickedLayer) {
        info.color = pickedColor;
        info.index = pickedObjectIndex;
        info.picked = true;
      }

      // Walk up the composite chain and find the owner of the event
      // sublayers are never directly exposed to the user
      while (layer && info) {
        // For a composite layer, sourceLayer will point to the sublayer
        // where the event originates from.
        // It provides additional context for the composite layer's
        // getPickingInfo() method to populate the info object
        var sourceLayer = info.layer || layer;
        info.layer = layer;
        // layer.pickLayer() function requires a non-null ```layer.state```
        // object to funtion properly. So the layer refereced here
        // must be the "current" layer, not an "out-dated" / "invalidated" layer
        info = layer.pickLayer({ info: info, mode: mode, sourceLayer: sourceLayer });
        layer = layer.parentLayer;
      }

      // This guarantees that there will be only one copy of info for
      // one composite layer
      if (info) {
        infos.set(info.layer.id, info);
      }
    });

    infos.forEach(function (info) {
      var handled = false;
      // The onClick and onHover functions are provided by the user
      // and out of control by deck.gl. It's very much possible that
      // the user calls React lifecycle methods in these function, such as
      // ReactComponent.setState(). React lifecycle methods sometimes induce
      // a re-render and re-generation of props of deck.gl and its layers,
      // which invalidates all layers currently passed to this very function.

      // Therefore, calls to functions like onClick and onHover need to be done
      // at the end of the function. NO operation relies on the states of current
      // layers should be called after this two lines of code.
      switch (mode) {
        case 'click':
          handled = info.layer.props.onClick(info);break;
        case 'hover':
          handled = info.layer.props.onHover(info);break;
        default:
          throw new Error('unknown pick type');
      }

      if (!handled) {
        unhandledPickInfos.push(info);
      }
    });
  });

  return unhandledPickInfos;
}
/* eslint-enable max-depth, max-statements */

function createInfo(pixel, viewport) {
  // Assign a number of potentially useful props to the "info" object
  return {
    color: EMPTY_PIXEL,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    lngLat: viewport.unproject(pixel)
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZHJhdy1hbmQtcGljay5qcyJdLCJuYW1lcyI6WyJkcmF3TGF5ZXJzIiwicGlja0xheWVycyIsIkVNUFRZX1BJWEVMIiwiVWludDhBcnJheSIsInJlbmRlckNvdW50IiwibGF5ZXJzIiwicGFzcyIsImxvZyIsImxlbmd0aCIsInZpc2libGVDb3VudCIsImZvckVhY2giLCJsYXllciIsImxheWVySW5kZXgiLCJpc0NvbXBvc2l0ZSIsInByb3BzIiwidmlzaWJsZSIsImRyYXdMYXllciIsInVuaWZvcm1zIiwiT2JqZWN0IiwiYXNzaWduIiwicmVuZGVyUGlja2luZ0J1ZmZlciIsInBpY2tpbmdFbmFibGVkIiwiY29udGV4dCIsInZpZXdwb3J0IiwiZ2wiLCJwaWNraW5nRkJPIiwieCIsInkiLCJtb2RlIiwibGFzdFBpY2tlZEluZm8iLCJwaXhlbFJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImRldmljZVgiLCJkZXZpY2VZIiwiY2FudmFzIiwiaGVpZ2h0IiwidW5oYW5kbGVkUGlja0luZm9zIiwiZnJhbWVCdWZmZXIiLCJmcmFtZWJ1ZmZlciIsInNjaXNzb3JUZXN0IiwidyIsImgiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJERVBUSF9CVUZGRVJfQklUIiwib2xkQmxlbmRNb2RlIiwiZW5hYmxlIiwiQkxFTkQiLCJibGVuZEZ1bmNTZXBhcmF0ZSIsIk9ORSIsIlpFUk8iLCJDT05TVEFOVF9BTFBIQSIsImJsZW5kRXF1YXRpb24iLCJGVU5DX0FERCIsInBpY2thYmxlIiwiYmxlbmRDb2xvciIsInBpY2tlZENvbG9yIiwicmVhZFBpeGVscyIsIlJHQkEiLCJVTlNJR05FRF9CWVRFIiwicGlja2VkTGF5ZXJJbmRleCIsInBpY2tlZExheWVyIiwicGlja2VkT2JqZWN0SW5kZXgiLCJkZWNvZGVQaWNraW5nQ29sb3IiLCJwaWNrZWRMYXllcklkIiwiaWQiLCJhZmZlY3RlZExheWVycyIsImxhc3RQaWNrZWRPYmplY3RJbmRleCIsImluZGV4IiwibGFzdFBpY2tlZExheWVySWQiLCJsYXllcklkIiwibGFzdFBpY2tlZExheWVyIiwiZmluZCIsImwiLCJ1bnNoaWZ0IiwiYmFzZUluZm8iLCJjcmVhdGVJbmZvIiwiZGV2aWNlUGl4ZWwiLCJpbmZvcyIsIk1hcCIsImluZm8iLCJjb2xvciIsInBpY2tlZCIsInNvdXJjZUxheWVyIiwicGlja0xheWVyIiwicGFyZW50TGF5ZXIiLCJzZXQiLCJoYW5kbGVkIiwib25DbGljayIsIm9uSG92ZXIiLCJFcnJvciIsInB1c2giLCJwaXhlbCIsImxuZ0xhdCIsInVucHJvamVjdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUE0QmdCQSxVLEdBQUFBLFU7UUF5QkFDLFUsR0FBQUEsVTs7QUFoQ2hCOztBQUNBOztBQUNBOztBQUVBLElBQU1DLGNBQWMsSUFBSUMsVUFBSixDQUFlLENBQWYsQ0FBcEIsQyxDQXpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFNQSxJQUFJQyxjQUFjLENBQWxCOztBQUVPLFNBQVNKLFVBQVQsT0FBb0M7QUFBQSxNQUFmSyxNQUFlLFFBQWZBLE1BQWU7QUFBQSxNQUFQQyxJQUFPLFFBQVBBLElBQU87O0FBQ3pDLGFBQUlDLEdBQUosQ0FBUSxDQUFSLGVBQXNCRixPQUFPRyxNQUE3Qjs7QUFFQTtBQUNBLE1BQUlDLGVBQWUsQ0FBbkI7QUFDQTtBQUNBSixTQUFPSyxPQUFQLENBQWUsVUFBQ0MsS0FBRCxFQUFRQyxVQUFSLEVBQXVCO0FBQ3BDLFFBQUksQ0FBQ0QsTUFBTUUsV0FBUCxJQUFzQkYsTUFBTUcsS0FBTixDQUFZQyxPQUF0QyxFQUErQztBQUM3Q0osWUFBTUssU0FBTixDQUFnQjtBQUNkQyxrQkFBVUMsT0FBT0MsTUFBUCxDQUNSLEVBQUNDLHFCQUFxQixDQUF0QixFQUF5QkMsZ0JBQWdCLENBQXpDLEVBRFEsRUFFUlYs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QUFpQjJFLE9BQWpCLENBQXlCUixJQUF6QixDQUFWLENBQTBDO0FBQ3hELGFBQUssT0FBTDtBQUFjTyxvQkFBVVAsS0FBS3RFLEtBQUwsQ0FBV0csS0FBWCxDQUFpQjRFLE9BQWpCLENBQXlCVCxJQUF6QixDQUFWLENBQTBDO0FBQ3hEO0FBQVMsZ0JBQU0sSUFBSVUsS0FBSixDQUFVLG1CQUFWLENBQU47QUFIVDs7QUFNQSxVQUFJLENBQUNILE9BQUwsRUFBYztBQUNabkQsMkJBQW1CdUQsSUFBbkIsQ0FBd0JYLElBQXhCO0FBQ0Q7QUFDRixLQXJCRDtBQXNCRCxHQTdJRDs7QUErSUEsU0FBTzVDLGtCQUFQO0FBQ0Q7QUFDRDs7QUFFQSxTQUFTd0MsVUFBVCxDQUFvQmdCLEtBQXBCLEVBQTJCdEUsUUFBM0IsRUFBcUM7QUFDbkM7QUFDQSxTQUFPO0FBQ0wyRCxXQUFPaEYsV0FERjtBQUVMbUUsV0FBTyxDQUFDLENBRkg7QUFHTGMsWUFBUSxLQUhIO0FBSUx6RCxPQUFHbUUsTUFBTSxDQUFOLENBSkU7QUFLTGxFLE9BQUdrRSxNQUFNLENBQU4sQ0FMRTtBQU1MQSxnQkFOSztBQU9MQyxZQUFRdkUsU0FBU3dFLFNBQVQsQ0FBbUJGLEtBQW5CO0FBUEgsR0FBUDtBQVNEIiwiZmlsZSI6ImRyYXctYW5kLXBpY2suanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IHtHTCwgZ2xDb250ZXh0V2l0aFN0YXRlfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7Z2V0VW5pZm9ybXNGcm9tVmlld3BvcnR9IGZyb20gJy4vdmlld3BvcnQtdW5pZm9ybXMnO1xuaW1wb3J0IHtsb2csIGdldEJsZW5kTW9kZSwgc2V0QmxlbmRNb2RlfSBmcm9tICcuL3V0aWxzJztcblxuY29uc3QgRU1QVFlfUElYRUwgPSBuZXcgVWludDhBcnJheSg0KTtcbmxldCByZW5kZXJDb3VudCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3TGF5ZXJzKHtsYXllcnMsIHBhc3N9KSB7XG4gIGxvZy5sb2coMywgYERSQVdJTkcgJHtsYXllcnMubGVuZ3RofSBsYXllcnNgKTtcblxuICAvLyByZW5kZXIgbGF5ZXJzIGluIG5vcm1hbCBjb2xvcnNcbiAgbGV0IHZpc2libGVDb3VudCA9IDA7XG4gIC8vIHJlbmRlciBsYXllcnMgaW4gbm9ybWFsIGNvbG9yc1xuICBsYXllcnMuZm9yRWFjaCgobGF5ZXIsIGxheWVySW5kZXgpID0+IHtcbiAgICBpZiAoIWxheWVyLmlzQ29tcG9zaXRlICYmIGxheWVyLnByb3BzLnZpc2libGUpIHtcbiAgICAgIGxheWVyLmRyYXdMYXllcih7XG4gICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHtyZW5kZXJQaWNraW5nQnVmZmVyOiAwLCBwaWNraW5nRW5hYmxlZDogMH0sXG4gICAgICAgICAgbGF5ZXIuY29udGV4dC51bmlmb3JtcyxcbiAgICAgICAgICBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydChsYXllci5jb250ZXh0LnZpZXdwb3J0LCBsYXllci5wcm9wcyksXG4gICAgICAgICAge2xheWVySW5kZXh9XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgdmlzaWJsZUNvdW50Kys7XG4gICAgfVxuICB9KTtcblxuICBsb2cubG9nKDMsIGBSRU5ERVIgUEFTUyAke3Bhc3N9OiAke3JlbmRlckNvdW50Kyt9XG4gICAgJHt2aXNpYmxlQ291bnR9IHZpc2libGUsICR7bGF5ZXJzLmxlbmd0aH0gdG90YWxgKTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWRlcHRoLCBtYXgtc3RhdGVtZW50cyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpY2tMYXllcnMoZ2wsIHtcbiAgbGF5ZXJzLFxuICBwaWNraW5nRkJPLFxuICB1bmlmb3JtcyA9IHt9LFxuICB4LFxuICB5LFxuICB2aWV3cG9ydCxcbiAgbW9kZSxcbiAgbGFzdFBpY2tlZEluZm9cbn0pIHtcblxuICAvLyBDb252ZXJ0IGZyb20gY2FudmFzIHRvcC1sZWZ0IHRvIFdlYkdMIGJvdHRvbS1sZWZ0IGNvb3JkaW5hdGVzXG4gIC8vIEFuZCBjb21wZW5zYXRlIGZvciBwaXhlbFJhdGlvXG4gIGNvbnN0IHBpeGVsUmF0aW8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xuICBjb25zdCBkZXZpY2VYID0geCAqIHBpeGVsUmF0aW87XG4gIGNvbnN0IGRldmljZVkgPSBnbC5jYW52YXMuaGVpZ2h0IC0geSAqIHBpeGVsUmF0aW87XG5cbiAgLy8gVE9ETyAtIGp1c3QgcmV0dXJuIGdsQ29udGV4dFdpdGhTdGF0ZSBvbmNlIGx1bWEgdXBkYXRlc1xuICBjb25zdCB1bmhhbmRsZWRQaWNrSW5mb3MgPSBbXTtcblxuICAvLyBNYWtlIHN1cmUgd2UgY2xlYXIgc2Npc3NvciB0ZXN0IGFuZCBmYm8gYmluZGluZ3MgaW4gY2FzZSBvZiBleGNlcHRpb25zXG4gIC8vIFdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gb25lIHBpeGVsLCBubyBuZWVkIHRvIHJlbmRlciBhbnl0aGluZyBlbHNlXG4gIGdsQ29udGV4dFdpdGhTdGF0ZShnbCwge1xuICAgIGZyYW1lQnVmZmVyOiBwaWNraW5nRkJPLFxuICAgIGZyYW1lYnVmZmVyOiBwaWNraW5nRkJPLFxuICAgIHNjaXNzb3JUZXN0OiB7eDogZGV2aWNlWCwgeTogZGV2aWNlWSwgdzogMSwgaDogMX1cbiAgfSwgKCkgPT4ge1xuXG4gICAgLy8gUGlja2luZyBwcm9jZXNzIHN0YXJ0XG4gICAgLy8gQ2xlYXIgdGhlIGZyYW1lIGJ1ZmZlclxuICAgIGdsLmNsZWFyKEdMLkNPTE9SX0JVRkZFUl9CSVQgfCBHTC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICAvLyBTYXZlIGN1cnJlbnQgYmxlbmQgc2V0dGluZ3NcbiAgICBjb25zdCBvbGRCbGVuZE1vZGUgPSBnZXRCbGVuZE1vZGUoZ2wpO1xuICAgIC8vIFNldCBibGVuZCBtb2RlIGZvciBwaWNraW5nXG4gICAgLy8gYWx3YXlzIG92ZXJ3cml0ZSBleGlzdGluZyBwaXhlbCB3aXRoIFtyLGcsYixsYXllckluZGV4XVxuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuT05FLCBnbC5aRVJPLCBnbC5DT05TVEFOVF9BTFBIQSwgZ2wuWkVSTyk7XG4gICAgZ2wuYmxlbmRFcXVhdGlvbihnbC5GVU5DX0FERCk7XG5cbiAgICAvLyBSZW5kZXIgYWxsIHBpY2thYmxlIGxheWVycyBpbiBwaWNraW5nIGNvbG9yc1xuICAgIGxheWVycy5mb3JFYWNoKChsYXllciwgbGF5ZXJJbmRleCkgPT4ge1xuICAgICAgaWYgKCFsYXllci5pc0NvbXBvc2l0ZSAmJiBsYXllci5wcm9wcy52aXNpYmxlICYmIGxheWVyLnByb3BzLnBpY2thYmxlKSB7XG5cbiAgICAgICAgLy8gRW5jb2RlIGxheWVySW5kZXggd2l0aCBhbHBoYVxuICAgICAgICBnbC5ibGVuZENvbG9yKDAsIDAsIDAsIChsYXllckluZGV4ICsgMSkgLyAyNTUpO1xuXG4gICAgICAgIGxheWVyLmRyYXdMYXllcih7XG4gICAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7cmVuZGVyUGlja2luZ0J1ZmZlcjogMSwgcGlja2luZ0VuYWJsZWQ6IDF9LFxuICAgICAgICAgICAgbGF5ZXIuY29udGV4dC51bmlmb3JtcyxcbiAgICAgICAgICAgIGdldFVuaWZvcm1zRnJvbVZpZXdwb3J0KGxheWVyLmNvbnRleHQudmlld3BvcnQsIGxheWVyLnByb3BzKSxcbiAgICAgICAgICAgIHtsYXllckluZGV4fVxuICAgICAgICAgIClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZWFkIGNvbG9yIGluIHRoZSBjZW50cmFsIHBpeGVsLCB0byBiZSBtYXBwZWQgd2l0aCBwaWNraW5nIGNvbG9yc1xuICAgIGNvbnN0IHBpY2tlZENvbG9yID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgZ2wucmVhZFBpeGVscyhkZXZpY2VYLCBkZXZpY2VZLCAxLCAxLCBHTC5SR0JBLCBHTC5VTlNJR05FRF9CWVRFLCBwaWNrZWRDb2xvcik7XG5cbiAgICAvLyByZXN0b3JlIGJsZW5kIG1vZGVcbiAgICBzZXRCbGVuZE1vZGUoZ2wsIG9sZEJsZW5kTW9kZSk7XG4gICAgLy8gUGlja2luZyBwcm9jZXNzIGVuZFxuXG4gICAgLy8gUHJvY2VzcyBwaWNrZWQgaW5mbyBzdGFydFxuICAgIC8vIERlY29kZSBwaWNrZWQgY29sb3JcbiAgICBjb25zdCBwaWNrZWRMYXllckluZGV4ID0gcGlja2VkQ29sb3JbM10gLSAxO1xuICAgIGNvbnN0IHBpY2tlZExheWVyID0gcGlja2VkTGF5ZXJJbmRleCA+PSAwID8gbGF5ZXJzW3BpY2tlZExheWVySW5kZXhdIDogbnVsbDtcbiAgICBjb25zdCBwaWNrZWRPYmplY3RJbmRleCA9IHBpY2tlZExheWVyID8gcGlja2VkTGF5ZXIuZGVjb2RlUGlja2luZ0NvbG9yKHBpY2tlZENvbG9yKSA6IC0xO1xuICAgIGNvbnN0IHBpY2tlZExheWVySWQgPSBwaWNrZWRMYXllciAmJiBwaWNrZWRMYXllci5wcm9wcy5pZDtcbiAgICBjb25zdCBhZmZlY3RlZExheWVycyA9IHBpY2tlZExheWVyID8gW3BpY2tlZExheWVyXSA6IFtdO1xuXG4gICAgaWYgKG1vZGUgPT09ICdob3ZlcicpIHtcbiAgICAgIC8vIG9ubHkgaW52b2tlIG9uSG92ZXIgZXZlbnRzIGlmIHBpY2tlZCBvYmplY3QgaGFzIGNoYW5nZWRcbiAgICAgIGNvbnN0IGxhc3RQaWNrZWRPYmplY3RJbmRleCA9IGxhc3RQaWNrZWRJbmZvLmluZGV4O1xuICAgICAgY29uc3QgbGFzdFBpY2tlZExheWVySWQgPSBsYXN0UGlja2VkSW5mby5sYXllcklkO1xuXG4gICAgICBpZiAocGlja2VkTGF5ZXJJZCA9PT0gbGFzdFBpY2tlZExheWVySWQgJiYgcGlja2VkT2JqZWN0SW5kZXggPT09IGxhc3RQaWNrZWRPYmplY3RJbmRleCkge1xuICAgICAgICAvLyBwaWNrZWQgb2JqZWN0IGRpZCBub3QgY2hhbmdlLCBubyBuZWVkIHRvIHByb2NlZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGlja2VkTGF5ZXJJZCAhPT0gbGFzdFBpY2tlZExheWVySWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHN0b3JlIGEgcmVmIHRvIGxhc3RQaWNrZWRMYXllciBpbiB0aGUgY29udGV4dCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBzdGF0ZSBvZiBhbiBvdXRkYXRlZCBsYXllciBpcyBubyBsb25nZXIgdmFsaWRcbiAgICAgICAgLy8gYW5kIHRoZSBwcm9wcyBtYXkgaGF2ZSBjaGFuZ2VkXG4gICAgICAgIGNvbnN0IGxhc3RQaWNrZWRMYXllciA9IGxheWVycy5maW5kKGwgPT4gbC5wcm9wcy5pZCA9PT0gbGFzdFBpY2tlZExheWVySWQpO1xuICAgICAgICBpZiAobGFzdFBpY2tlZExheWVyKSB7XG4gICAgICAgICAgLy8gTGV0IGxlYXZlIGV2ZW50IGZpcmUgYmVmb3JlIGVudGVyIGV2ZW50XG4gICAgICAgICAgYWZmZWN0ZWRMYXllcnMudW5zaGlmdChsYXN0UGlja2VkTGF5ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBsYXllciBtYW5hZ2VyIGNvbnRleHRcbiAgICAgIGxhc3RQaWNrZWRJbmZvLmxheWVySWQgPSBwaWNrZWRMYXllcklkO1xuICAgICAgbGFzdFBpY2tlZEluZm8uaW5kZXggPSBwaWNrZWRPYmplY3RJbmRleDtcbiAgICB9XG5cbiAgICBjb25zdCBiYXNlSW5mbyA9IGNyZWF0ZUluZm8oW3gsIHldLCB2aWV3cG9ydCk7XG4gICAgYmFzZUluZm8uZGV2aWNlUGl4ZWwgPSBbZGV2aWNlWCwgZGV2aWNlWV07XG4gICAgYmFzZUluZm8ucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG5cbiAgICAvLyBVc2UgYSBNYXAgdG8gc3RvcmUgYWxsIHBpY2tpbmcgaW5mb3MuXG4gICAgLy8gVGhlIGZvbGxvd2luZyB0d28gZm9yRWFjaCBsb29wcyBhcmUgdGhlIHJlc3VsdCBvZlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91YmVyL2RlY2suZ2wvaXNzdWVzLzQ0M1xuICAgIC8vIFBsZWFzZSBiZSB2ZXJ5IGNhcmVmdWwgd2hlbiBjaGFuZ2luZyB0aGlzIHBhdHRlcm5cbiAgICBjb25zdCBpbmZvcyA9IG5ldyBNYXAoKTtcblxuICAgIGFmZmVjdGVkTGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgbGV0IGluZm8gPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlSW5mbyk7XG5cbiAgICAgIGlmIChsYXllciA9PT0gcGlja2VkTGF5ZXIpIHtcbiAgICAgICAgaW5mby5jb2xvciA9IHBpY2tlZENvbG9yO1xuICAgICAgICBpbmZvLmluZGV4ID0gcGlja2VkT2JqZWN0SW5kZXg7XG4gICAgICAgIGluZm8ucGlja2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2FsayB1cCB0aGUgY29tcG9zaXRlIGNoYWluIGFuZCBmaW5kIHRoZSBvd25lciBvZiB0aGUgZXZlbnRcbiAgICAgIC8vIHN1YmxheWVycyBhcmUgbmV2ZXIgZGlyZWN0bHkgZXhwb3NlZCB0byB0aGUgdXNlclxuICAgICAgd2hpbGUgKGxheWVyICYmIGluZm8pIHtcbiAgICAgICAgLy8gRm9yIGEgY29tcG9zaXRlIGxheWVyLCBzb3VyY2VMYXllciB3aWxsIHBvaW50IHRvIHRoZSBzdWJsYXllclxuICAgICAgICAvLyB3aGVyZSB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tLlxuICAgICAgICAvLyBJdCBwcm92aWRlcyBhZGRpdGlvbmFsIGNvbnRleHQgZm9yIHRoZSBjb21wb3NpdGUgbGF5ZXInc1xuICAgICAgICAvLyBnZXRQaWNraW5nSW5mbygpIG1ldGhvZCB0byBwb3B1bGF0ZSB0aGUgaW5mbyBvYmplY3RcbiAgICAgICAgY29uc3Qgc291cmNlTGF5ZXIgPSBpbmZvLmxheWVyIHx8IGxheWVyO1xuICAgICAgICBpbmZvLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIC8vIGxheWVyLnBpY2tMYXllcigpIGZ1bmN0aW9uIHJlcXVpcmVzIGEgbm9uLW51bGwgYGBgbGF5ZXIuc3RhdGVgYGBcbiAgICAgICAgLy8gb2JqZWN0IHRvIGZ1bnRpb24gcHJvcGVybHkuIFNvIHRoZSBsYXllciByZWZlcmVjZWQgaGVyZVxuICAgICAgICAvLyBtdXN0IGJlIHRoZSBcImN1cnJlbnRcIiBsYXllciwgbm90IGFuIFwib3V0LWRhdGVkXCIgLyBcImludmFsaWRhdGVkXCIgbGF5ZXJcbiAgICAgICAgaW5mbyA9IGxheWVyLnBpY2tMYXllcih7aW5mbywgbW9kZSwgc291cmNlTGF5ZXJ9KTtcbiAgICAgICAgbGF5ZXIgPSBsYXllci5wYXJlbnRMYXllcjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBndWFyYW50ZWVzIHRoYXQgdGhlcmUgd2lsbCBiZSBvbmx5IG9uZSBjb3B5IG9mIGluZm8gZm9yXG4gICAgICAvLyBvbmUgY29tcG9zaXRlIGxheWVyXG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBpbmZvcy5zZXQoaW5mby5sYXllci5pZCwgaW5mbyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpbmZvcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgIC8vIFRoZSBvbkNsaWNrIGFuZCBvbkhvdmVyIGZ1bmN0aW9ucyBhcmUgcHJvdmlkZWQgYnkgdGhlIHVzZXJcbiAgICAgIC8vIGFuZCBvdXQgb2YgY29udHJvbCBieSBkZWNrLmdsLiBJdCdzIHZlcnkgbXVjaCBwb3NzaWJsZSB0aGF0XG4gICAgICAvLyB0aGUgdXNlciBjYWxscyBSZWFjdCBsaWZlY3ljbGUgbWV0aG9kcyBpbiB0aGVzZSBmdW5jdGlvbiwgc3VjaCBhc1xuICAgICAgLy8gUmVhY3RDb21wb25lbnQuc2V0U3RhdGUoKS4gUmVhY3QgbGlmZWN5Y2xlIG1ldGhvZHMgc29tZXRpbWVzIGluZHVjZVxuICAgICAgLy8gYSByZS1yZW5kZXIgYW5kIHJlLWdlbmVyYXRpb24gb2YgcHJvcHMgb2YgZGVjay5nbCBhbmQgaXRzIGxheWVycyxcbiAgICAgIC8vIHdoaWNoIGludmFsaWRhdGVzIGFsbCBsYXllcnMgY3VycmVudGx5IHBhc3NlZCB0byB0aGlzIHZlcnkgZnVuY3Rpb24uXG5cbiAgICAgIC8vIFRoZXJlZm9yZSwgY2FsbHMgdG8gZnVuY3Rpb25zIGxpa2Ugb25DbGljayBhbmQgb25Ib3ZlciBuZWVkIHRvIGJlIGRvbmVcbiAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uLiBOTyBvcGVyYXRpb24gcmVsaWVzIG9uIHRoZSBzdGF0ZXMgb2YgY3VycmVudFxuICAgICAgLy8gbGF5ZXJzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcyB0d28gbGluZXMgb2YgY29kZS5cbiAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSAnY2xpY2snOiBoYW5kbGVkID0gaW5mby5sYXllci5wcm9wcy5vbkNsaWNrKGluZm8pOyBicmVhaztcbiAgICAgIGNhc2UgJ2hvdmVyJzogaGFuZGxlZCA9IGluZm8ubGF5ZXIucHJvcHMub25Ib3ZlcihpbmZvKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcGljayB0eXBlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZGxlZCkge1xuICAgICAgICB1bmhhbmRsZWRQaWNrSW5mb3MucHVzaChpbmZvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHVuaGFuZGxlZFBpY2tJbmZvcztcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoLCBtYXgtc3RhdGVtZW50cyAqL1xuXG5mdW5jdGlvbiBjcmVhdGVJbmZvKHBpeGVsLCB2aWV3cG9ydCkge1xuICAvLyBBc3NpZ24gYSBudW1iZXIgb2YgcG90ZW50aWFsbHkgdXNlZnVsIHByb3BzIHRvIHRoZSBcImluZm9cIiBvYmplY3RcbiAgcmV0dXJuIHtcbiAgICBjb2xvcjogRU1QVFlfUElYRUwsXG4gICAgaW5kZXg6IC0xLFxuICAgIHBpY2tlZDogZmFsc2UsXG4gICAgeDogcGl4ZWxbMF0sXG4gICAgeTogcGl4ZWxbMV0sXG4gICAgcGl4ZWwsXG4gICAgbG5nTGF0OiB2aWV3cG9ydC51bnByb2plY3QocGl4ZWwpXG4gIH07XG59XG4iXX0=