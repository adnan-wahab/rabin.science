'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TEST_EXPORTS = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */


var _constants = require('./constants');

var _attributeManager = require('./attribute-manager');

var _attributeManager2 = _interopRequireDefault(_attributeManager);

var _utils = require('./utils');

var _luma = require('luma.gl');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LOG_PRIORITY_UPDATE = 2;

/*
 * @param {string} props.id - layer name
 * @param {array}  props.data - array of data instances
 * @param {bool} props.opacity - opacity of the layer
 */
var defaultProps = {
  dataComparator: null,
  numInstances: undefined,
  visible: true,
  pickable: false,
  opacity: 0.8,
  onHover: function onHover() {},
  onClick: function onClick() {},
  // Update triggers: a key change detection mechanism in deck.gl
  // See layer documentation
  updateTriggers: {},
  projectionMode: _constants.COORDINATE_SYSTEM.LNGLAT
};

var counter = 0;

var Layer = function () {
  /**
   * @class
   * @param {object} props - See docs and defaults above
   */
  function Layer(props) {
    _classCallCheck(this, Layer);

    // If sublayer has static defaultProps member, getDefaultProps will return it
    var mergedDefaultProps = getDefaultProps(this);
    // Merge supplied props with pre-merged default props
    props = Object.assign({}, mergedDefaultProps, props);
    // Accept null as data - otherwise apps and layers need to add ugly checks
    props.data = props.data || [];
    // Props are immutable
    Object.freeze(props);

    // Define all members and freeze layer
    this.id = props.id;
    this.props = props;
    this.oldProps = null;
    this.state = null;
    this.context = null;
    this.parentLayer = null;
    this.count = counter++;
    this.lifecycle = _constants.LIFECYCLE.NO_STATE;
    Object.seal(this);
  }

  _createClass(Layer, [{
    key: 'toString',
    value: function toString() {
      var className = this.constructor.layerName || this.constructor.name;
      return className !== this.props.id ? '<' + className + ':\'' + this.props.id + '\'>' : '<' + className + '>';
    }

    // //////////////////////////////////////////////////
    // LIFECYCLE METHODS, overridden by the layer subclasses

    // Called once to set up the initial state
    // App can create WebGL resources

  }, {
    key: 'initializeState',
    value: function initializeState() {
      throw new Error('Layer ' + this + ' has not defined initializeState');
    }

    // Let's layer control if updateState should be called

  }, {
    key: 'shouldUpdateState',
    value: function shouldUpdateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          oldContext = _ref.oldContext,
          context = _ref.context,
          changeFlags = _ref.changeFlags;

      return changeFlags.somethingChanged;
    }

    // Default implementation, all attributes will be invalidated and updated
    // when data changes

  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var oldProps = _ref2.oldProps,
          props = _ref2.props,
          oldContext = _ref2.oldContext,
          context = _ref2.context,
          changeFlags = _ref2.changeFlags;

      if (changeFlags.dataChanged) {
        this.invalidateAttribute('all');
      }
    }

    // Called once when layer is no longer matched and state will be discarded
    // App can destroy WebGL resources here

  }, {
    key: 'finalizeState',
    value: function finalizeState() {}

    // If state has a model, draw it with supplied uniforms

  }, {
    key: 'draw',
    value: function draw(_ref3) {
      var _ref3$uniforms = _ref3.uniforms,
          uniforms = _ref3$uniforms === undefined ? {} : _ref3$uniforms;

      if (this.state.model) {
        this.state.model.render(uniforms);
      }
    }

    // called to populate the info object that is passed to the event handler
    // @return null to cancel event

  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref4) {
      var info = _ref4.info,
          mode = _ref4.mode;
      var color = info.color,
          index = info.index;


      if (index >= 0) {
        // If props.data is an indexable array, get the object
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }

      // TODO - move to the JS part of a shader picking shader package
      if (mode === 'hover') {
        var selectedPickingColor = new Float32Array(3);
        selectedPickingColor[0] = color[0];
        selectedPickingColor[1] = color[1];
        selectedPickingColor[2] = color[2];
        this.setUniforms({ selectedPickingColor: selectedPickingColor });
      }

      return info;
    }

    // END LIFECYCLE METHODS
    // //////////////////////////////////////////////////

    // Default implementation of attribute invalidation, can be redefine

  }, {
    key: 'invalidateAttribute',
    value: function invalidateAttribute() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';

      if (name === 'all') {
        this.state.attributeManager.invalidateAll();
      } else {
        this.state.attributeManager.invalidate(name);
      }
    }

    // Calls attribute manager to update any WebGL attributes, can be redefined

  }, {
    key: 'updateAttributes',
    value: function updateAttributes(props) {
      var _state = this.state,
          attributeManager = _state.attributeManager,
          model = _state.model;

      if (!attributeManager) {
        return;
      }

      var numInstances = this.getNumInstances(props);
      // Figure out data length
      attributeManager.update({
        data: props.data,
        numInstances: numInstances,
        props: props,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });
      if (model) {
        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
        model.setAttributes(changedAttributes);
      }
    }

    // Public API

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setState',
    value: function setState(updateObject) {
      Object.assign(this.state, updateObject);
      this.state.needsRedraw = true;
    }
  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.state) {
        this.state.needsRedraw = redraw;
      }
    }

    // PROJECTION METHODS

    /**
     * Projects a point with current map state (lat, lon, zoom, pitch, bearing)
     *
     * Note: Position conversion is done in shader, so in many cases there is no need
     * for this function
     * @param {Array|TypedArray} lngLat - long and lat values
     * @return {Array|TypedArray} - x, y coordinates
     */

  }, {
    key: 'project',
    value: function project(lngLat) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.project(lngLat);
    }
  }, {
    key: 'unproject',
    value: function unproject(xy) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unproject(xy);
    }
  }, {
    key: 'projectFlat',
    value: function projectFlat(lngLat) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.projectFlat(lngLat);
    }
  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xy) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unprojectFlat(xy);
    }
  }, {
    key: 'screenToDevicePixels',
    value: function screenToDevicePixels(screenPixels) {
      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
      return screenPixels * devicePixelRatio;
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @return {Array} - a black color
     */

  }, {
    key: 'nullPickingColor',
    value: function nullPickingColor() {
      return [0, 0, 0];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {int} i - index to be decoded
     * @return {Array} - the decoded color
     */

  }, {
    key: 'encodePickingColor',
    value: function encodePickingColor(i) {
      return [(i + 1) % 256, Math.floor((i + 1) / 256) % 256, Math.floor((i + 1) / 256 / 256) % 256];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {Uint8Array} color - color array to be decoded
     * @return {Array} - the decoded picking color
     */

  }, {
    key: 'decodePickingColor',
    value: function decodePickingColor(color) {
      (0, _assert2.default)(color instanceof Uint8Array);

      var _color = _slicedToArray(color, 3),
          i1 = _color[0],
          i2 = _color[1],
          i3 = _color[2];
      // 1 was added to seperate from no selection


      var index = i1 + i2 * 256 + i3 * 65536 - 1;
      return index;
    }
  }, {
    key: 'calculateInstancePickingColors',
    value: function calculateInstancePickingColors(attribute, _ref5) {
      var numInstances = _ref5.numInstances;
      var value = attribute.value,
          size = attribute.size;
      // add 1 to index to seperate from no selection

      for (var i = 0; i < numInstances; i++) {
        var pickingColor = this.encodePickingColor(i);
        value[i * size + 0] = pickingColor[0];
        value[i * size + 1] = pickingColor[1];
        value[i * size + 2] = pickingColor[2];
      }
    }

    // DATA ACCESS API
    // Data can use iterators and may not be random access

    // Use iteration (the only required capability on data) to get first element

  }, {
    key: 'getFirstObject',
    value: function getFirstObject() {
      var data = this.props.data;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          return object;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }

    // INTERNAL METHODS

    // Deduces numer of instances. Intention is to support:
    // - Explicit setting of numInstances
    // - Auto-deduction for ES6 containers that define a size member
    // - Auto-deduction for Classic Arrays via the built-in length attribute
    // - Auto-deduction via arrays

  }, {
    key: 'getNumInstances',
    value: function getNumInstances(props) {
      props = props || this.props;

      // First check if the layer has set its own value
      if (this.state && this.state.numInstances !== undefined) {
        return this.state.numInstances;
      }

      // Check if app has provided an explicit value
      if (props.numInstances !== undefined) {
        return props.numInstances;
      }

      // Use container library to get a count for any ES6 container or object
      var _props = props,
          data = _props.data;

      return (0, _utils.count)(data);
    }

    // LAYER MANAGER API
    // Should only be called by the deck.gl LayerManager class

    // Called by layer manager when a new layer is found
    /* eslint-disable max-statements */

  }, {
    key: 'initializeLayer',
    value: function initializeLayer(updateParams) {
      (0, _assert2.default)(this.context.gl, 'Layer context missing gl');
      (0, _assert2.default)(!this.state, 'Layer missing state');

      this.state = {};

      // Initialize state only once
      this.setState({
        attributeManager: new _attributeManager2.default({ id: this.props.id }),
        model: null,
        needsRedraw: true,
        dataChanged: true
      });

      var attributeManager = this.state.attributeManager;
      // All instanced layers get instancePickingColors attribute by default
      // Their shaders can use it to render a picking scene
      // TODO - this slows down non instanced layers

      attributeManager.addInstanced({
        instancePickingColors: {
          type: _luma.GL.UNSIGNED_BYTE,
          size: 3,
          update: this.calculateInstancePickingColors
        }
      });

      // Call subclass lifecycle methods
      this.initializeState();
      this.updateState(updateParams);
      // End subclass lifecycle methods

      // Add any subclass attributes
      this.updateAttributes(this.props);
      this._updateBaseUniforms();

      var model = this.state.model;

      if (model) {
        model.setInstanceCount(this.getNumInstances());
        model.id = this.props.id;
        model.program.id = this.props.id + '-program';
        model.geometry.id = this.props.id + '-geometry';
        model.setAttributes(attributeManager.getAttributes());
      }
    }

    // Called by layer manager when existing layer is getting new props

  }, {
    key: 'updateLayer',
    value: function updateLayer(updateParams) {
      // Check for deprecated method
      if (this.shouldUpdate) {
        _utils.log.once(0, 'deck.gl v3 ' + this + ': "shouldUpdate" deprecated, renamed to "shouldUpdateState"');
      }

      // Call subclass lifecycle method
      var stateNeedsUpdate = this.shouldUpdateState(updateParams);
      // End lifecycle method

      if (stateNeedsUpdate) {
        // Call subclass lifecycle method
        this.updateState(updateParams);
        // End lifecycle method

        // Run the attribute updaters
        this.updateAttributes(updateParams.props);
        this._updateBaseUniforms();

        if (this.state.model) {
          this.state.model.setInstanceCount(this.getNumInstances());
        }
      }
    }
    /* eslint-enable max-statements */

    // Called by manager when layer is about to be disposed
    // Note: not guaranteed to be called on application shutdown

  }, {
    key: 'finalizeLayer',
    value: function finalizeLayer() {
      // Call subclass lifecycle method
      this.finalizeState();
      // End lifecycle method
    }

    // Calculates uniforms

  }, {
    key: 'drawLayer',
    value: function drawLayer(_ref6) {
      var _ref6$uniforms = _ref6.uniforms,
          uniforms = _ref6$uniforms === undefined ? {} : _ref6$uniforms;

      // Call subclass lifecycle method
      this.draw({ uniforms: uniforms });
      // End lifecycle method
    }

    // {uniforms = {}, ...opts}

  }, {
    key: 'pickLayer',
    value: function pickLayer(opts) {
      // Call subclass lifecycle method
      return this.getPickingInfo(opts);
      // End lifecycle method
    }
  }, {
    key: 'diffProps',
    value: function diffProps(oldProps, newProps, context) {
      // First check if any props have changed (ignore props that will be examined separately)
      var propsChangedReason = (0, _utils.compareProps)({
        newProps: newProps,
        oldProps: oldProps,
        ignoreProps: { data: null, updateTriggers: null }
      });

      // Now check if any data related props have changed
      var dataChangedReason = this._diffDataProps(oldProps, newProps);

      var propsChanged = Boolean(propsChangedReason);
      var dataChanged = Boolean(dataChangedReason);
      var viewportChanged = context.viewportChanged;
      var somethingChanged = propsChanged || dataChanged || viewportChanged;

      // Check update triggers to determine if any attributes need regeneration
      // Note - if data has changed, all attributes will need regeneration, so skip this step
      if (!dataChanged) {
        this._diffUpdateTriggers(oldProps, newProps);
      } else {
        _utils.log.log(2, 'dataChanged: ' + dataChanged);
      }

      return {
        propsChanged: propsChanged,
        dataChanged: dataChanged,
        viewportChanged: viewportChanged,
        somethingChanged: somethingChanged,
        reason: dataChangedReason || propsChangedReason
      };
    }

    // Checks state of attributes and model
    // TODO - is attribute manager needed? - Model should be enough.

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref7$clearRedrawFlag = _ref7.clearRedrawFlags,
          clearRedrawFlags = _ref7$clearRedrawFlag === undefined ? false : _ref7$clearRedrawFlag;

      // this method may be called by the render loop as soon a the layer
      // has been created, so guard against uninitialized state
      if (!this.state) {
        return false;
      }

      var redraw = false;
      redraw = redraw || this.state.needsRedraw;
      this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags;

      var _state2 = this.state,
          attributeManager = _state2.attributeManager,
          model = _state2.model;

      redraw = redraw || attributeManager && attributeManager.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
      redraw = redraw || model && model.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });

      return redraw;
    }

    // PRIVATE METHODS

    // The comparison of the data prop requires special handling
    // the dataComparator should be used if supplied

  }, {
    key: '_diffDataProps',
    value: function _diffDataProps(oldProps, newProps) {
      // Support optional app defined comparison of data
      var dataComparator = newProps.dataComparator;

      if (dataComparator) {
        if (!dataComparator(newProps.data, oldProps.data)) {
          return 'Data comparator detected a change';
        }
        // Otherwise, do a shallow equal on props
      } else if (newProps.data !== oldProps.data) {
        return 'A new data container was supplied';
      }

      return null;
    }

    // Checks if any update triggers have changed, and invalidate
    // attributes accordingly.
    /* eslint-disable max-statements */

  }, {
    key: '_diffUpdateTriggers',
    value: function _diffUpdateTriggers(oldProps, newProps) {
      // const {attributeManager} = this.state;
      // const updateTriggerMap = attributeManager.getUpdateTriggerMap();

      var change = false;

      for (var propName in newProps.updateTriggers) {
        var oldTriggers = oldProps.updateTriggers[propName] || {};
        var newTriggers = newProps.updateTriggers[propName] || {};
        var diffReason = (0, _utils.compareProps)({
          oldProps: oldTriggers,
          newProps: newTriggers
        });
        if (diffReason) {
          if (propName === 'all') {
            _utils.log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating all attributes: ' + diffReason);
            this.invalidateAttribute('all');
            change = true;
          } else {
            _utils.log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating attribute ' + propName + ': ' + diffReason);
            this.invalidateAttribute(propName);
            change = true;
          }
        }
      }

      return change;
    }
    /* eslint-enable max-statements */

  }, {
    key: '_checkRequiredProp',
    value: function _checkRequiredProp(propertyName, condition) {
      var value = this.props[propertyName];
      if (value === undefined) {
        throw new Error('Property ' + propertyName + ' undefined in layer ' + this);
      }
      if (condition && !condition(value)) {
        throw new Error('Bad property ' + propertyName + ' in layer ' + this);
      }
    }

    // Emits a warning if an old prop is used, optionally suggesting a replacement

  }, {
    key: '_checkRemovedProp',
    value: function _checkRemovedProp(oldProp) {
      var newProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.props[oldProp] !== undefined) {
        var layerName = this.constructor;
        var message = layerName + ' no longer accepts props.' + oldProp + ' in this version of deck.gl.';
        if (newProp) {
          message += '\nPlease use props.' + newProp + ' instead.';
        }
        _utils.log.once(0, message);
      }
    }
  }, {
    key: '_updateBaseUniforms',
    value: function _updateBaseUniforms() {
      this.setUniforms({
        // apply gamma to opacity to make it visually "linear"
        opacity: Math.pow(this.props.opacity, 1 / 2.2),
        ONE: 1.0
      });
    }

    // DEPRECATED METHODS

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setUniforms',
    value: function setUniforms(uniformMap) {
      if (this.state.model) {
        this.state.model.setUniforms(uniformMap);
      }
      // TODO - set needsRedraw on the model?
      this.state.needsRedraw = true;
      (0, _utils.log)(3, 'layer.setUniforms', uniformMap);
    }
  }]);

  return Layer;
}();

exports.default = Layer;


Layer.layerName = 'Layer';
Layer.defaultProps = defaultProps;

// HELPERS

// Constructors have their super class constructors as prototypes
function getOwnProperty(object, prop) {
  return object.hasOwnProperty(prop) && object[prop];
}
/*
 * Return merged default props stored on layers constructor, create them if needed
 */
function getDefaultProps(layer) {
  var mergedDefaultProps = getOwnProperty(layer.constructor, 'mergedDefaultProps');
  if (mergedDefaultProps) {
    return mergedDefaultProps;
  }
  return mergeDefaultProps(layer);
}

/*
 * Walk the prototype chain and merge all default props
 */
function mergeDefaultProps(layer) {
  var subClassConstructor = layer.constructor;
  var layerName = getOwnProperty(subClassConstructor, 'layerName');
  if (!layerName) {
    _utils.log.once(0, 'layer ' + layer.constructor.name + ' does not specify a "layerName"');
  }
  var mergedDefaultProps = {
    id: layerName || layer.constructor.name
  };

  while (layer) {
    var layerDefaultProps = getOwnProperty(layer.constructor, 'defaultProps');
    Object.freeze(layerDefaultProps);
    if (layerDefaultProps) {
      mergedDefaultProps = Object.assign({}, layerDefaultProps, mergedDefaultProps);
    }
    layer = Object.getPrototypeOf(layer);
  }
  // Store for quick lookup
  subClassConstructor.mergedDefaultProps = mergedDefaultProps;
  return mergedDefaultProps;
}

var TEST_EXPORTS = exports.TEST_EXPORTS = {
  mergeDefaultProps: mergeDefaultProps
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbGF5ZXIuanMiXSwibmFtZXMiOlsiTE9HX1BSSU9SSVRZX1VQREFURSIsImRlZmF1bHRQcm9wcyIsImRhdGFDb21wYXJhdG9yIiwibnVtSW5zdGFuY2VzIiwidW5kZWZpbmVkIiwidmlzaWJsZSIsInBpY2thYmxlIiwib3BhY2l0eSIsIm9uSG92ZXIiLCJvbkNsaWNrIiwidXBkYXRlVHJpZ2dlcnMiLCJwcm9qZWN0aW9uTW9kZSIsIkxOR0xBVCIsImNvdW50ZXIiLCJMYXllciIsInByb3BzIiwibWVyZ2VkRGVmYXVsdFByb3BzIiwiZ2V0RGVmYXVsdFByb3BzIiwiT2JqZWN0IiwiYXNzaWduIiwiZGF0YSIsImZyZWV6ZSIsImlkIiwib2xkUHJvcHMiLCJzdGF0ZSIsImNvbnRleHQiLCJwYXJlbnRMYXllciIsImNvdW50IiwibGlmZWN5Y2xlIiwiTk9fU1RBVEUiLCJzZWFsIiwiY2xhc3NOYW1lIiwiY29uc3RydWN0b3IiLCJsYXllck5hbWUiLCJuYW1lIiwiRXJyb3IiLCJvbGRDb250ZXh0IiwiY2hhbmdlRmxhZ3MiLCJzb21ldGhpbmdDaGFuZ2VkIiwiZGF0YUNoYW5nZWQiLCJpbnZhbGlkYXRlQXR0cmlidXRlIiwidW5pZm9ybXMiLCJtb2RlbCIsInJlbmRlciIsImluZm8iLCJtb2RlIiwiY29sb3IiLCJpbmRleCIsIkFycmF5IiwiaXNBcnJheSIsIm9iamVjdCIsInNlbGVjdGVkUGlja2luZ0NvbG9yIiwiRmxvYXQzMkFycmF5Iiwic2V0VW5pZm9ybXMiLCJhdHRyaWJ1dGVNYW5hZ2VyIiwiaW52YWxpZGF0ZUFsbCIsImludmFsaWRhdGUiLCJnZXROdW1JbnN0YW5jZXMiLCJ1cGRhdGUiLCJidWZmZXJzIiwiaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMiLCJjaGFuZ2VkQXR0cmlidXRlcyIsImdldENoYW5nZWRBdHRyaWJ1dGVzIiwiY2xlYXJDaGFuZ2VkRmxhZ3MiLCJzZXRBdHRyaWJ1dGVzIiwidXBkYXRlT2JqZWN0IiwibmVlZHNSZWRyYXciLCJyZWRyYXciLCJsbmdMYXQiLCJ2aWV3cG9ydCIsInByb2plY3QiLCJ4eSIsInVucHJvamVjdCIsInByb2plY3RGbGF0IiwidW5wcm9qZWN0RmxhdCIsInNjcmVlblBpeGVscyIsImRldmljZVBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJpIiwiTWF0aCIsImZsb29yIiwiVWludDhBcnJheSIsImkxIiwiaTIiLCJpMyIsImF0dHJpYnV0ZSIsInZhbHVlIiwic2l6ZSIsInBpY2tpbmdDb2xvciIsImVuY29kZVBpY2tpbmdDb2xvciIsInVwZGF0ZVBhcmFtcyIsImdsIiwic2V0U3RhdGUiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZVBpY2tpbmdDb2xvcnMiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsImNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9ycyIsImluaXRpYWxpemVTdGF0ZSIsInVwZGF0ZVN0YXRlIiwidXBkYXRlQXR0cmlidXRlcyIsIl91cGRhdGVCYXNlVW5pZm9ybXMiLCJzZXRJbnN0YW5jZUNvdW50IiwicHJvZ3JhbSIsImdlb21ldHJ5IiwiZ2V0QXR0cmlidXRlcyIsInNob3VsZFVwZGF0ZSIsIm9uY2UiLCJzdGF0ZU5lZWRzVXBkYXRlIiwic2hvdWxkVXBkYXRlU3RhdGUiLCJmaW5hbGl6ZVN0YXRlIiwiZHJhdyIsIm9wdHMiLCJnZXRQaWNraW5nSW5mbyIsIm5ld1Byb3BzIiwicHJvcHNDaGFuZ2VkUmVhc29uIiwiaWdub3JlUHJvcHMiLCJkYXRhQ2hhbmdlZFJlYXNvbiIsIl9kaWZmRGF0YVByb3BzIiwicHJvcHNDaGFuZ2VkIiwiQm9vbGVhbiIsInZpZXdwb3J0Q2hhbmdlZCIsIl9kaWZmVXBkYXRlVHJpZ2dlcnMiLCJsb2ciLCJyZWFzb24iLCJjbGVhclJlZHJhd0ZsYWdzIiwiZ2V0TmVlZHNSZWRyYXciLCJjaGFuZ2UiLCJwcm9wTmFtZSIsIm9sZFRyaWdnZXJzIiwibmV3VHJpZ2dlcnMiLCJkaWZmUmVhc29uIiwicHJvcGVydHlOYW1lIiwiY29uZGl0aW9uIiwib2xkUHJvcCIsIm5ld1Byb3AiLCJtZXNzYWdlIiwicG93IiwiT05FIiwidW5pZm9ybU1hcCIsImdldE93blByb3BlcnR5IiwicHJvcCIsImhhc093blByb3BlcnR5IiwibGF5ZXIiLCJtZXJnZURlZmF1bHRQcm9wcyIsInN1YkNsYXNzQ29uc3RydWN0b3IiLCJsYXllckRlZmF1bHRQcm9wcyIsImdldFByb3RvdHlwZU9mIiwiVEVTVF9FWFBPUlRTIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7cWpCQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQUVBLElBQU1BLHNCQUFzQixDQUE1Qjs7QUFFQTs7Ozs7QUFLQSxJQUFNQyxlQUFlO0FBQ25CQyxrQkFBZ0IsSUFERztBQUVuQkMsZ0JBQWNDLFNBRks7QUFHbkJDLFdBQVMsSUFIVTtBQUluQkMsWUFBVSxLQUpTO0FBS25CQyxXQUFTLEdBTFU7QUFNbkJDLFdBQVMsbUJBQU0sQ0FBRSxDQU5FO0FBT25CQyxXQUFTLG1CQUFNLENBQUUsQ0FQRTtBQVFuQjtBQUNBO0FBQ0FDLGtCQUFnQixFQVZHO0FBV25CQyxrQkFBZ0IsNkJBQWtCQztBQVhmLENBQXJCOztBQWNBLElBQUlDLFVBQVUsQ0FBZDs7SUFFcUJDLEs7QUFDbkI7Ozs7QUFJQSxpQkFBWUMsS0FBWixFQUFtQjtBQUFBOztBQUNqQjtBQUNBLFFBQU1DLHFCQUFxQkMsZ0JBQWdCLElBQWhCLENBQTNCO0FBQ0E7QUFDQUYsWUFBUUcsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JILGtCQUFsQixFQUFzQ0QsS0FBdEMsQ0FBUjtBQUNBO0FBQ0FBLFVBQU1LLElBQU4sR0FBYUwsTUFBTUssSUFBTixJQUFjLEVBQTNCO0FBQ0E7QUFDQUYsV0FBT0csTUFBUCxDQUFjTixLQUFkOztBQUVBO0FBQ0EsU0FB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InNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNLCBMSUZFQ1lDTEV9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBBdHRyaWJ1dGVNYW5hZ2VyIGZyb20gJy4vYXR0cmlidXRlLW1hbmFnZXInO1xuaW1wb3J0IHtsb2csIGNvbXBhcmVQcm9wcywgY291bnR9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHtHTH0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IExPR19QUklPUklUWV9VUERBVEUgPSAyO1xuXG4vKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BzLmlkIC0gbGF5ZXIgbmFtZVxuICogQHBhcmFtIHthcnJheX0gIHByb3BzLmRhdGEgLSBhcnJheSBvZiBkYXRhIGluc3RhbmNlc1xuICogQHBhcmFtIHtib29sfSBwcm9wcy5vcGFjaXR5IC0gb3BhY2l0eSBvZiB0aGUgbGF5ZXJcbiAqL1xuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBkYXRhQ29tcGFyYXRvcjogbnVsbCxcbiAgbnVtSW5zdGFuY2VzOiB1bmRlZmluZWQsXG4gIHZpc2libGU6IHRydWUsXG4gIHBpY2thYmxlOiBmYWxzZSxcbiAgb3BhY2l0eTogMC44LFxuICBvbkhvdmVyOiAoKSA9PiB7fSxcbiAgb25DbGljazogKCkgPT4ge30sXG4gIC8vIFVwZGF0ZSB0cmlnZ2VyczogYSBrZXkgY2hhbmdlIGRldGVjdGlvbiBtZWNoYW5pc20gaW4gZGVjay5nbFxuICAvLyBTZWUgbGF5ZXIgZG9jdW1lbnRhdGlvblxuICB1cGRhdGVUcmlnZ2Vyczoge30sXG4gIHByb2plY3Rpb25Nb2RlOiBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVRcbn07XG5cbmxldCBjb3VudGVyID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyAtIFNlZSBkb2NzIGFuZCBkZWZhdWx0cyBhYm92ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAvLyBJZiBzdWJsYXllciBoYXMgc3RhdGljIGRlZmF1bHRQcm9wcyBtZW1iZXIsIGdldERlZmF1bHRQcm9wcyB3aWxsIHJldHVybiBpdFxuICAgIGNvbnN0IG1lcmdlZERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcyh0aGlzKTtcbiAgICAvLyBNZXJnZSBzdXBwbGllZCBwcm9wcyB3aXRoIHByZS1tZXJnZWQgZGVmYXVsdCBwcm9wc1xuICAgIHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbWVyZ2VkRGVmYXVsdFByb3BzLCBwcm9wcyk7XG4gICAgLy8gQWNjZXB0IG51bGwgYXMgZGF0YSAtIG90aGVyd2lzZSBhcHBzIGFuZCBsYXllcnMgbmVlZCB0byBhZGQgdWdseSBjaGVja3NcbiAgICBwcm9wcy5kYXRhID0gcHJvcHMuZGF0YSB8fCBbXTtcbiAgICAvLyBQcm9wcyBhcmUgaW1tdXRhYmxlXG4gICAgT2JqZWN0LmZyZWV6ZShwcm9wcyk7XG5cbiAgICAvLyBEZWZpbmUgYWxsIG1lbWJlcnMgYW5kIGZyZWV6ZSBsYXllclxuICAgIHRoaXMuaWQgPSBwcm9wcy5pZDtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5vbGRQcm9wcyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLnBhcmVudExheWVyID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ID0gY291bnRlcisrO1xuICAgIHRoaXMubGlmZWN5Y2xlID0gTElGRUNZQ0xFLk5PX1NUQVRFO1xuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5sYXllck5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHJldHVybiBjbGFzc05hbWUgIT09IHRoaXMucHJvcHMuaWQgPyBgPCR7Y2xhc3NOYW1lfTonJHt0aGlzLnByb3BzLmlkfSc+YCA6IGA8JHtjbGFzc05hbWV9PmA7XG4gIH1cblxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBMSUZFQ1lDTEUgTUVUSE9EUywgb3ZlcnJpZGRlbiBieSB0aGUgbGF5ZXIgc3ViY2xhc3Nlc1xuXG4gIC8vIENhbGxlZCBvbmNlIHRvIHNldCB1cCB0aGUgaW5pdGlhbCBzdGF0ZVxuICAvLyBBcHAgY2FuIGNyZWF0ZSBXZWJHTCByZXNvdXJjZXNcbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTGF5ZXIgJHt0aGlzfSBoYXMgbm90IGRlZmluZWQgaW5pdGlhbGl6ZVN0YXRlYCk7XG4gIH1cblxuICAvLyBMZXQncyBsYXllciBjb250cm9sIGlmIHVwZGF0ZVN0YXRlIHNob3VsZCBiZSBjYWxsZWRcbiAgc2hvdWxkVXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgb2xkQ29udGV4dCwgY29udGV4dCwgY2hhbmdlRmxhZ3N9KSB7XG4gICAgcmV0dXJuIGNoYW5nZUZsYWdzLnNvbWV0aGluZ0NoYW5nZWQ7XG4gIH1cblxuICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uLCBhbGwgYXR0cmlidXRlcyB3aWxsIGJlIGludmFsaWRhdGVkIGFuZCB1cGRhdGVkXG4gIC8vIHdoZW4gZGF0YSBjaGFuZ2VzXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIG9sZENvbnRleHQsIGNvbnRleHQsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlQXR0cmlidXRlKCdhbGwnKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgb25jZSB3aGVuIGxheWVyIGlzIG5vIGxvbmdlciBtYXRjaGVkIGFuZCBzdGF0ZSB3aWxsIGJlIGRpc2NhcmRlZFxuICAvLyBBcHAgY2FuIGRlc3Ryb3kgV2ViR0wgcmVzb3VyY2VzIGhlcmVcbiAgZmluYWxpemVTdGF0ZSgpIHtcbiAgfVxuXG4gIC8vIElmIHN0YXRlIGhhcyBhIG1vZGVsLCBkcmF3IGl0IHdpdGggc3VwcGxpZWQgdW5pZm9ybXNcbiAgZHJhdyh7dW5pZm9ybXMgPSB7fX0pIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGxlZCB0byBwb3B1bGF0ZSB0aGUgaW5mbyBvYmplY3QgdGhhdCBpcyBwYXNzZWQgdG8gdGhlIGV2ZW50IGhhbmRsZXJcbiAgLy8gQHJldHVybiBudWxsIHRvIGNhbmNlbCBldmVudFxuICBnZXRQaWNraW5nSW5mbyh7aW5mbywgbW9kZX0pIHtcbiAgICBjb25zdCB7Y29sb3IsIGluZGV4fSA9IGluZm87XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgLy8gSWYgcHJvcHMuZGF0YSBpcyBhbiBpbmRleGFibGUgYXJyYXksIGdldCB0aGUgb2JqZWN0XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnByb3BzLmRhdGEpKSB7XG4gICAgICAgIGluZm8ub2JqZWN0ID0gdGhpcy5wcm9wcy5kYXRhW2luZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPIC0gbW92ZSB0byB0aGUgSlMgcGFydCBvZiBhIHNoYWRlciBwaWNraW5nIHNoYWRlciBwYWNrYWdlXG4gICAgaWYgKG1vZGUgPT09ICdob3ZlcicpIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkUGlja2luZ0NvbG9yID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgIHNlbGVjdGVkUGlja2luZ0NvbG9yWzBdID0gY29sb3JbMF07XG4gICAgICBzZWxlY3RlZFBpY2tpbmdDb2xvclsxXSA9IGNvbG9yWzFdO1xuICAgICAgc2VsZWN0ZWRQaWNraW5nQ29sb3JbMl0gPSBjb2xvclsyXTtcbiAgICAgIHRoaXMuc2V0VW5pZm9ybXMoe3NlbGVjdGVkUGlja2luZ0NvbG9yfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICAvLyBFTkQgTElGRUNZQ0xFIE1FVEhPRFNcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGF0dHJpYnV0ZSBpbnZhbGlkYXRpb24sIGNhbiBiZSByZWRlZmluZVxuICBpbnZhbGlkYXRlQXR0cmlidXRlKG5hbWUgPSAnYWxsJykge1xuICAgIGlmIChuYW1lID09PSAnYWxsJykge1xuICAgICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGUobmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbHMgYXR0cmlidXRlIG1hbmFnZXIgdG8gdXBkYXRlIGFueSBXZWJHTCBhdHRyaWJ1dGVzLCBjYW4gYmUgcmVkZWZpbmVkXG4gIHVwZGF0ZUF0dHJpYnV0ZXMocHJvcHMpIHtcbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlciwgbW9kZWx9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoIWF0dHJpYnV0ZU1hbmFnZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBudW1JbnN0YW5jZXMgPSB0aGlzLmdldE51bUluc3RhbmNlcyhwcm9wcyk7XG4gICAgLy8gRmlndXJlIG91dCBkYXRhIGxlbmd0aFxuICAgIGF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlKHtcbiAgICAgIGRhdGE6IHByb3BzLmRhdGEsXG4gICAgICBudW1JbnN0YW5jZXMsXG4gICAgICBwcm9wcyxcbiAgICAgIGJ1ZmZlcnM6IHByb3BzLFxuICAgICAgY29udGV4dDogdGhpcyxcbiAgICAgIC8vIERvbid0IHdvcnJ5IGFib3V0IG5vbi1hdHRyaWJ1dGUgcHJvcHNcbiAgICAgIGlnbm9yZVVua25vd25BdHRyaWJ1dGVzOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBjb25zdCBjaGFuZ2VkQXR0cmlidXRlcyA9IGF0dHJpYnV0ZU1hbmFnZXIuZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMoe2NsZWFyQ2hhbmdlZEZsYWdzOiB0cnVlfSk7XG4gICAgICBtb2RlbC5zZXRBdHRyaWJ1dGVzKGNoYW5nZWRBdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH1cblxuICAvLyBQdWJsaWMgQVBJXG5cbiAgLy8gVXBkYXRlcyBzZWxlY3RlZCBzdGF0ZSBtZW1iZXJzIGFuZCBtYXJrcyB0aGUgb2JqZWN0IGZvciByZWRyYXdcbiAgc2V0U3RhdGUodXBkYXRlT2JqZWN0KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnN0YXRlLCB1cGRhdGVPYmplY3QpO1xuICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICB9XG5cbiAgc2V0TmVlZHNSZWRyYXcocmVkcmF3ID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLnN0YXRlKSB7XG4gICAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gcmVkcmF3O1xuICAgIH1cbiAgfVxuXG4gIC8vIFBST0pFQ1RJT04gTUVUSE9EU1xuXG4gIC8qKlxuICAgKiBQcm9qZWN0cyBhIHBvaW50IHdpdGggY3VycmVudCBtYXAgc3RhdGUgKGxhdCwgbG9uLCB6b29tLCBwaXRjaCwgYmVhcmluZylcbiAgICpcbiAgICogTm90ZTogUG9zaXRpb24gY29udmVyc2lvbiBpcyBkb25lIGluIHNoYWRlciwgc28gaW4gbWFueSBjYXNlcyB0aGVyZSBpcyBubyBuZWVkXG4gICAqIGZvciB0aGlzIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl8VHlwZWRBcnJheX0gbG5nTGF0IC0gbG9uZyBhbmQgbGF0IHZhbHVlc1xuICAgKiBAcmV0dXJuIHtBcnJheXxUeXBlZEFycmF5fSAtIHgsIHkgY29vcmRpbmF0ZXNcbiAgICovXG4gIHByb2plY3QobG5nTGF0KSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShsbmdMYXQpLCAnTGF5ZXIucHJvamVjdCBuZWVkcyBbbG5nLGxhdF0nKTtcbiAgICByZXR1cm4gdmlld3BvcnQucHJvamVjdChsbmdMYXQpO1xuICB9XG5cbiAgdW5wcm9qZWN0KHh5KSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh4eSksICdMYXllci51bnByb2plY3QgbmVlZHMgW3gseV0nKTtcbiAgICByZXR1cm4gdmlld3BvcnQudW5wcm9qZWN0KHh5KTtcbiAgfVxuXG4gIHByb2plY3RGbGF0KGxuZ0xhdCkge1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkobG5nTGF0KSwgJ0xheWVyLnByb2plY3QgbmVlZHMgW2xuZyxsYXRdJyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0LnByb2plY3RGbGF0KGxuZ0xhdCk7XG4gIH1cblxuICB1bnByb2plY3RGbGF0KHh5KSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh4eSksICdMYXllci51bnByb2plY3QgbmVlZHMgW3gseV0nKTtcbiAgICByZXR1cm4gdmlld3BvcnQudW5wcm9qZWN0RmxhdCh4eSk7XG4gIH1cblxuICBzY3JlZW5Ub0RldmljZVBpeGVscyhzY3JlZW5QaXhlbHMpIHtcbiAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xuICAgIHJldHVybiBzY3JlZW5QaXhlbHMgKiBkZXZpY2VQaXhlbFJhdGlvO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpY2tpbmcgY29sb3IgdGhhdCBkb2Vzbid0IG1hdGNoIGFueSBzdWJmZWF0dXJlXG4gICAqIFVzZSBpZiBzb21lIGdyYXBoaWNzIGRvIG5vdCBiZWxvbmcgdG8gYW55IHBpY2thYmxlIHN1YmZlYXR1cmVcbiAgICogQHJldHVybiB7QXJyYXl9IC0gYSBibGFjayBjb2xvclxuICAgKi9cbiAgbnVsbFBpY2tpbmdDb2xvcigpIHtcbiAgICByZXR1cm4gWzAsIDAsIDBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpY2tpbmcgY29sb3IgdGhhdCBkb2Vzbid0IG1hdGNoIGFueSBzdWJmZWF0dXJlXG4gICAqIFVzZSBpZiBzb21lIGdyYXBoaWNzIGRvIG5vdCBiZWxvbmcgdG8gYW55IHBpY2thYmxlIHN1YmZlYXR1cmVcbiAgICogQHBhcmFtIHtpbnR9IGkgLSBpbmRleCB0byBiZSBkZWNvZGVkXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIHRoZSBkZWNvZGVkIGNvbG9yXG4gICAqL1xuICBlbmNvZGVQaWNraW5nQ29sb3IoaSkge1xuICAgIHJldHVybiBbXG4gICAgICAoaSArIDEpICUgMjU2LFxuICAgICAgTWF0aC5mbG9vcigoaSArIDEpIC8gMjU2KSAlIDI1NixcbiAgICAgIE1hdGguZmxvb3IoKGkgKyAxKSAvIDI1NiAvIDI1NikgJSAyNTZcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpY2tpbmcgY29sb3IgdGhhdCBkb2Vzbid0IG1hdGNoIGFueSBzdWJmZWF0dXJlXG4gICAqIFVzZSBpZiBzb21lIGdyYXBoaWNzIGRvIG5vdCBiZWxvbmcgdG8gYW55IHBpY2thYmxlIHN1YmZlYXR1cmVcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBjb2xvciAtIGNvbG9yIGFycmF5IHRvIGJlIGRlY29kZWRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gdGhlIGRlY29kZWQgcGlja2luZyBjb2xvclxuICAgKi9cbiAgZGVjb2RlUGlja2luZ0NvbG9yKGNvbG9yKSB7XG4gICAgYXNzZXJ0KGNvbG9yIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgY29uc3QgW2kxLCBpMiwgaTNdID0gY29sb3I7XG4gICAgLy8gMSB3YXMgYWRkZWQgdG8gc2VwZXJhdGUgZnJvbSBubyBzZWxlY3Rpb25cbiAgICBjb25zdCBpbmRleCA9IGkxICsgaTIgKiAyNTYgKyBpMyAqIDY1NTM2IC0gMTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnMoYXR0cmlidXRlLCB7bnVtSW5zdGFuY2VzfSkge1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgLy8gYWRkIDEgdG8gaW5kZXggdG8gc2VwZXJhdGUgZnJvbSBubyBzZWxlY3Rpb25cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUluc3RhbmNlczsgaSsrKSB7XG4gICAgICBjb25zdCBwaWNraW5nQ29sb3IgPSB0aGlzLmVuY29kZVBpY2tpbmdDb2xvcihpKTtcbiAgICAgIHZhbHVlW2kgKiBzaXplICsgMF0gPSBwaWNraW5nQ29sb3JbMF07XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDFdID0gcGlja2luZ0NvbG9yWzFdO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAyXSA9IHBpY2tpbmdDb2xvclsyXTtcbiAgICB9XG4gIH1cblxuICAvLyBEQVRBIEFDQ0VTUyBBUElcbiAgLy8gRGF0YSBjYW4gdXNlIGl0ZXJhdG9ycyBhbmQgbWF5IG5vdCBiZSByYW5kb20gYWNjZXNzXG5cbiAgLy8gVXNlIGl0ZXJhdGlvbiAodGhlIG9ubHkgcmVxdWlyZWQgY2FwYWJpbGl0eSBvbiBkYXRhKSB0byBnZXQgZmlyc3QgZWxlbWVudFxuICBnZXRGaXJzdE9iamVjdCgpIHtcbiAgICBjb25zdCB7ZGF0YX0gPSB0aGlzLnByb3BzO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSU5URVJOQUwgTUVUSE9EU1xuXG4gIC8vIERlZHVjZXMgbnVtZXIgb2YgaW5zdGFuY2VzLiBJbnRlbnRpb24gaXMgdG8gc3VwcG9ydDpcbiAgLy8gLSBFeHBsaWNpdCBzZXR0aW5nIG9mIG51bUluc3RhbmNlc1xuICAvLyAtIEF1dG8tZGVkdWN0aW9uIGZvciBFUzYgY29udGFpbmVycyB0aGF0IGRlZmluZSBhIHNpemUgbWVtYmVyXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gZm9yIENsYXNzaWMgQXJyYXlzIHZpYSB0aGUgYnVpbHQtaW4gbGVuZ3RoIGF0dHJpYnV0ZVxuICAvLyAtIEF1dG8tZGVkdWN0aW9uIHZpYSBhcnJheXNcbiAgZ2V0TnVtSW5zdGFuY2VzKHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB0aGlzLnByb3BzO1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIGxheWVyIGhhcyBzZXQgaXRzIG93biB2YWx1ZVxuICAgIGlmICh0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUubnVtSW5zdGFuY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLm51bUluc3RhbmNlcztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhcHAgaGFzIHByb3ZpZGVkIGFuIGV4cGxpY2l0IHZhbHVlXG4gICAgaWYgKHByb3BzLm51bUluc3RhbmNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvcHMubnVtSW5zdGFuY2VzO1xuICAgIH1cblxuICAgIC8vIFVzZSBjb250YWluZXIgbGlicmFyeSB0byBnZXQgYSBjb3VudCBmb3IgYW55IEVTNiBjb250YWluZXIgb3Igb2JqZWN0XG4gICAgY29uc3Qge2RhdGF9ID0gcHJvcHM7XG4gICAgcmV0dXJuIGNvdW50KGRhdGEpO1xuICB9XG5cbiAgLy8gTEFZRVIgTUFOQUdFUiBBUElcbiAgLy8gU2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJ5IHRoZSBkZWNrLmdsIExheWVyTWFuYWdlciBjbGFzc1xuXG4gIC8vIENhbGxlZCBieSBsYXllciBtYW5hZ2VyIHdoZW4gYSBuZXcgbGF5ZXIgaXMgZm91bmRcbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgaW5pdGlhbGl6ZUxheWVyKHVwZGF0ZVBhcmFtcykge1xuICAgIGFzc2VydCh0aGlzLmNvbnRleHQuZ2wsICdMYXllciBjb250ZXh0IG1pc3NpbmcgZ2wnKTtcbiAgICBhc3NlcnQoIXRoaXMuc3RhdGUsICdMYXllciBtaXNzaW5nIHN0YXRlJyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge307XG5cbiAgICAvLyBJbml0aWFsaXplIHN0YXRlIG9ubHkgb25jZVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgYXR0cmlidXRlTWFuYWdlcjogbmV3IEF0dHJpYnV0ZU1hbmFnZXIoe2lkOiB0aGlzLnByb3BzLmlkfSksXG4gICAgICBtb2RlbDogbnVsbCxcbiAgICAgIG5lZWRzUmVkcmF3OiB0cnVlLFxuICAgICAgZGF0YUNoYW5nZWQ6IHRydWVcbiAgICB9KTtcblxuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgLy8gQWxsIGluc3RhbmNlZCBsYXllcnMgZ2V0IGluc3RhbmNlUGlja2luZ0NvbG9ycyBhdHRyaWJ1dGUgYnkgZGVmYXVsdFxuICAgIC8vIFRoZWlyIHNoYWRlcnMgY2FuIHVzZSBpdCB0byByZW5kZXIgYSBwaWNraW5nIHNjZW5lXG4gICAgLy8gVE9ETyAtIHRoaXMgc2xvd3MgZG93biBub24gaW5zdGFuY2VkIGxheWVyc1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkSW5zdGFuY2VkKHtcbiAgICAgIGluc3RhbmNlUGlja2luZ0NvbG9yczoge1xuICAgICAgICB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLFxuICAgICAgICBzaXplOiAzLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VQaWNraW5nQ29sb3JzXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDYWxsIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RzXG4gICAgdGhpcy5pbml0aWFsaXplU3RhdGUoKTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG4gICAgLy8gRW5kIHN1YmNsYXNzIGxpZmVjeWNsZSBtZXRob2RzXG5cbiAgICAvLyBBZGQgYW55IHN1YmNsYXNzIGF0dHJpYnV0ZXNcbiAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXModGhpcy5wcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlQmFzZVVuaWZvcm1zKCk7XG5cbiAgICBjb25zdCB7bW9kZWx9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIG1vZGVsLnNldEluc3RhbmNlQ291bnQodGhpcy5nZXROdW1JbnN0YW5jZXMoKSk7XG4gICAgICBtb2RlbC5pZCA9IHRoaXMucHJvcHMuaWQ7XG4gICAgICBtb2RlbC5wcm9ncmFtLmlkID0gYCR7dGhpcy5wcm9wcy5pZH0tcHJvZ3JhbWA7XG4gICAgICBtb2RlbC5nZW9tZXRyeS5pZCA9IGAke3RoaXMucHJvcHMuaWR9LWdlb21ldHJ5YDtcbiAgICAgIG1vZGVsLnNldEF0dHJpYnV0ZXMoYXR0cmlidXRlTWFuYWdlci5nZXRBdHRyaWJ1dGVzKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCBieSBsYXllciBtYW5hZ2VyIHdoZW4gZXhpc3RpbmcgbGF5ZXIgaXMgZ2V0dGluZyBuZXcgcHJvcHNcbiAgdXBkYXRlTGF5ZXIodXBkYXRlUGFyYW1zKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGRlcHJlY2F0ZWQgbWV0aG9kXG4gICAgaWYgKHRoaXMuc2hvdWxkVXBkYXRlKSB7XG4gICAgICBsb2cub25jZSgwLCBgZGVjay5nbCB2MyAke3RoaXN9OiBcInNob3VsZFVwZGF0ZVwiIGRlcHJlY2F0ZWQsIHJlbmFtZWQgdG8gXCJzaG91bGRVcGRhdGVTdGF0ZVwiYCk7XG4gICAgfVxuXG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgY29uc3Qgc3RhdGVOZWVkc1VwZGF0ZSA9IHRoaXMuc2hvdWxkVXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuXG4gICAgaWYgKHN0YXRlTmVlZHNVcGRhdGUpIHtcbiAgICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh1cGRhdGVQYXJhbXMpO1xuICAgICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcblxuICAgICAgLy8gUnVuIHRoZSBhdHRyaWJ1dGUgdXBkYXRlcnNcbiAgICAgIHRoaXMudXBkYXRlQXR0cmlidXRlcyh1cGRhdGVQYXJhbXMucHJvcHMpO1xuICAgICAgdGhpcy5fdXBkYXRlQmFzZVVuaWZvcm1zKCk7XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlLm1vZGVsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0SW5zdGFuY2VDb3VudCh0aGlzLmdldE51bUluc3RhbmNlcygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIC8vIENhbGxlZCBieSBtYW5hZ2VyIHdoZW4gbGF5ZXIgaXMgYWJvdXQgdG8gYmUgZGlzcG9zZWRcbiAgLy8gTm90ZTogbm90IGd1YXJhbnRlZWQgdG8gYmUgY2FsbGVkIG9uIGFwcGxpY2F0aW9uIHNodXRkb3duXG4gIGZpbmFsaXplTGF5ZXIoKSB7XG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgdGhpcy5maW5hbGl6ZVN0YXRlKCk7XG4gICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZXMgdW5pZm9ybXNcbiAgZHJhd0xheWVyKHt1bmlmb3JtcyA9IHt9fSkge1xuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHRoaXMuZHJhdyh7dW5pZm9ybXN9KTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuICB9XG5cbiAgLy8ge3VuaWZvcm1zID0ge30sIC4uLm9wdHN9XG4gIHBpY2tMYXllcihvcHRzKSB7XG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgcmV0dXJuIHRoaXMuZ2V0UGlja2luZ0luZm8ob3B0cyk7XG4gICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcbiAgfVxuXG4gIGRpZmZQcm9wcyhvbGRQcm9wcywgbmV3UHJvcHMsIGNvbnRleHQpIHtcbiAgICAvLyBGaXJzdCBjaGVjayBpZiBhbnkgcHJvcHMgaGF2ZSBjaGFuZ2VkIChpZ25vcmUgcHJvcHMgdGhhdCB3aWxsIGJlIGV4YW1pbmVkIHNlcGFyYXRlbHkpXG4gICAgY29uc3QgcHJvcHNDaGFuZ2VkUmVhc29uID0gY29tcGFyZVByb3BzKHtcbiAgICAgIG5ld1Byb3BzLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBpZ25vcmVQcm9wczoge2RhdGE6IG51bGwsIHVwZGF0ZVRyaWdnZXJzOiBudWxsfVxuICAgIH0pO1xuXG4gICAgLy8gTm93IGNoZWNrIGlmIGFueSBkYXRhIHJlbGF0ZWQgcHJvcHMgaGF2ZSBjaGFuZ2VkXG4gICAgY29uc3QgZGF0YUNoYW5nZWRSZWFzb24gPSB0aGlzLl9kaWZmRGF0YVByb3BzKG9sZFByb3BzLCBuZXdQcm9wcyk7XG5cbiAgICBjb25zdCBwcm9wc0NoYW5nZWQgPSBCb29sZWFuKHByb3BzQ2hhbmdlZFJlYXNvbik7XG4gICAgY29uc3QgZGF0YUNoYW5nZWQgPSBCb29sZWFuKGRhdGFDaGFuZ2VkUmVhc29uKTtcbiAgICBjb25zdCB2aWV3cG9ydENoYW5nZWQgPSBjb250ZXh0LnZpZXdwb3J0Q2hhbmdlZDtcbiAgICBjb25zdCBzb21ldGhpbmdDaGFuZ2VkID0gcHJvcHNDaGFuZ2VkIHx8IGRhdGFDaGFuZ2VkIHx8IHZpZXdwb3J0Q2hhbmdlZDtcblxuICAgIC8vIENoZWNrIHVwZGF0ZSB0cmlnZ2VycyB0byBkZXRlcm1pbmUgaWYgYW55IGF0dHJpYnV0ZXMgbmVlZCByZWdlbmVyYXRpb25cbiAgICAvLyBOb3RlIC0gaWYgZGF0YSBoYXMgY2hhbmdlZCwgYWxsIGF0dHJpYnV0ZXMgd2lsbCBuZWVkIHJlZ2VuZXJhdGlvbiwgc28gc2tpcCB0aGlzIHN0ZXBcbiAgICBpZiAoIWRhdGFDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9kaWZmVXBkYXRlVHJpZ2dlcnMob2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLmxvZygyLCBgZGF0YUNoYW5nZWQ6ICR7ZGF0YUNoYW5nZWR9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3BzQ2hhbmdlZCxcbiAgICAgIGRhdGFDaGFuZ2VkLFxuICAgICAgdmlld3BvcnRDaGFuZ2VkLFxuICAgICAgc29tZXRoaW5nQ2hhbmdlZCxcbiAgICAgIHJlYXNvbjogZGF0YUNoYW5nZWRSZWFzb24gfHwgcHJvcHNDaGFuZ2VkUmVhc29uXG4gICAgfTtcbiAgfVxuXG4gIC8vIENoZWNrcyBzdGF0ZSBvZiBhdHRyaWJ1dGVzIGFuZCBtb2RlbFxuICAvLyBUT0RPIC0gaXMgYXR0cmlidXRlIG1hbmFnZXIgbmVlZGVkPyAtIE1vZGVsIHNob3VsZCBiZSBlbm91Z2guXG4gIGdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzID0gZmFsc2V9ID0ge30pIHtcbiAgICAvLyB0aGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIGJ5IHRoZSByZW5kZXIgbG9vcCBhcyBzb29uIGEgdGhlIGxheWVyXG4gICAgLy8gaGFzIGJlZW4gY3JlYXRlZCwgc28gZ3VhcmQgYWdhaW5zdCB1bmluaXRpYWxpemVkIHN0YXRlXG4gICAgaWYgKCF0aGlzLnN0YXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHJlZHJhdyA9IGZhbHNlO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3O1xuICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ICYmICFjbGVhclJlZHJhd0ZsYWdzO1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXIsIG1vZGVsfSA9IHRoaXMuc3RhdGU7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8IChhdHRyaWJ1dGVNYW5hZ2VyICYmIGF0dHJpYnV0ZU1hbmFnZXIuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KSk7XG4gICAgcmVkcmF3ID0gcmVkcmF3IHx8IChtb2RlbCAmJiBtb2RlbC5nZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFnc30pKTtcblxuICAgIHJldHVybiByZWRyYXc7XG4gIH1cblxuICAvLyBQUklWQVRFIE1FVEhPRFNcblxuICAvLyBUaGUgY29tcGFyaXNvbiBvZiB0aGUgZGF0YSBwcm9wIHJlcXVpcmVzIHNwZWNpYWwgaGFuZGxpbmdcbiAgLy8gdGhlIGRhdGFDb21wYXJhdG9yIHNob3VsZCBiZSB1c2VkIGlmIHN1cHBsaWVkXG4gIF9kaWZmRGF0YVByb3BzKG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgIC8vIFN1cHBvcnQgb3B0aW9uYWwgYXBwIGRlZmluZWQgY29tcGFyaXNvbiBvZiBkYXRhXG4gICAgY29uc3Qge2RhdGFDb21wYXJhdG9yfSA9IG5ld1Byb3BzO1xuICAgIGlmIChkYXRhQ29tcGFyYXRvcikge1xuICAgICAgaWYgKCFkYXRhQ29tcGFyYXRvcihuZXdQcm9wcy5kYXRhLCBvbGRQcm9wcy5kYXRhKSkge1xuICAgICAgICByZXR1cm4gJ0RhdGEgY29tcGFyYXRvciBkZXRlY3RlZCBhIGNoYW5nZSc7XG4gICAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBkbyBhIHNoYWxsb3cgZXF1YWwgb24gcHJvcHNcbiAgICB9IGVsc2UgaWYgKG5ld1Byb3BzLmRhdGEgIT09IG9sZFByb3BzLmRhdGEpIHtcbiAgICAgIHJldHVybiAnQSBuZXcgZGF0YSBjb250YWluZXIgd2FzIHN1cHBsaWVkJztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIENoZWNrcyBpZiBhbnkgdXBkYXRlIHRyaWdnZXJzIGhhdmUgY2hhbmdlZCwgYW5kIGludmFsaWRhdGVcbiAgLy8gYXR0cmlidXRlcyBhY2NvcmRpbmdseS5cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgX2RpZmZVcGRhdGVUcmlnZ2VycyhvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAvLyBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIGNvbnN0IHVwZGF0ZVRyaWdnZXJNYXAgPSBhdHRyaWJ1dGVNYW5hZ2VyLmdldFVwZGF0ZVRyaWdnZXJNYXAoKTtcblxuICAgIGxldCBjaGFuZ2UgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgcHJvcE5hbWUgaW4gbmV3UHJvcHMudXBkYXRlVHJpZ2dlcnMpIHtcbiAgICAgIGNvbnN0IG9sZFRyaWdnZXJzID0gb2xkUHJvcHMudXBkYXRlVHJpZ2dlcnNbcHJvcE5hbWVdIHx8IHt9O1xuICAgICAgY29uc3QgbmV3VHJpZ2dlcnMgPSBuZXdQcm9wcy51cGRhdGVUcmlnZ2Vyc1twcm9wTmFtZV0gfHwge307XG4gICAgICBjb25zdCBkaWZmUmVhc29uID0gY29tcGFyZVByb3BzKHtcbiAgICAgICAgb2xkUHJvcHM6IG9sZFRyaWdnZXJzLFxuICAgICAgICBuZXdQcm9wczogbmV3VHJpZ2dlcnNcbiAgICAgIH0pO1xuICAgICAgaWYgKGRpZmZSZWFzb24pIHtcbiAgICAgICAgaWYgKHByb3BOYW1lID09PSAnYWxsJykge1xuICAgICAgICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX1VQREFURSxcbiAgICAgICAgICAgIGB1cGRhdGVUcmlnZ2VycyBpbnZhbGlkYXRpbmcgYWxsIGF0dHJpYnV0ZXM6ICR7ZGlmZlJlYXNvbn1gKTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGVBdHRyaWJ1dGUoJ2FsbCcpO1xuICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nLmxvZyhMT0dfUFJJT1JJVFlfVVBEQVRFLFxuICAgICAgICAgICAgYHVwZGF0ZVRyaWdnZXJzIGludmFsaWRhdGluZyBhdHRyaWJ1dGUgJHtwcm9wTmFtZX06ICR7ZGlmZlJlYXNvbn1gKTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGVBdHRyaWJ1dGUocHJvcE5hbWUpO1xuICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICBfY2hlY2tSZXF1aXJlZFByb3AocHJvcGVydHlOYW1lLCBjb25kaXRpb24pIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMucHJvcHNbcHJvcGVydHlOYW1lXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9wZXJ0eSAke3Byb3BlcnR5TmFtZX0gdW5kZWZpbmVkIGluIGxheWVyICR7dGhpc31gKTtcbiAgICB9XG4gICAgaWYgKGNvbmRpdGlvbiAmJiAhY29uZGl0aW9uKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWQgcHJvcGVydHkgJHtwcm9wZXJ0eU5hbWV9IGluIGxheWVyICR7dGhpc31gKTtcbiAgICB9XG4gIH1cblxuICAvLyBFbWl0cyBhIHdhcm5pbmcgaWYgYW4gb2xkIHByb3AgaXMgdXNlZCwgb3B0aW9uYWxseSBzdWdnZXN0aW5nIGEgcmVwbGFjZW1lbnRcbiAgX2NoZWNrUmVtb3ZlZFByb3Aob2xkUHJvcCwgbmV3UHJvcCA9IG51bGwpIHtcbiAgICBpZiAodGhpcy5wcm9wc1tvbGRQcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBsYXllck5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgbGV0IG1lc3NhZ2UgPSBgJHtsYXllck5hbWV9IG5vIGxvbmdlciBhY2NlcHRzIHByb3BzLiR7b2xkUHJvcH0gaW4gdGhpcyB2ZXJzaW9uIG9mIGRlY2suZ2wuYDtcbiAgICAgIGlmIChuZXdQcm9wKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYFxcblBsZWFzZSB1c2UgcHJvcHMuJHtuZXdQcm9wfSBpbnN0ZWFkLmA7XG4gICAgICB9XG4gICAgICBsb2cub25jZSgwLCBtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlQmFzZVVuaWZvcm1zKCkge1xuICAgIHRoaXMuc2V0VW5pZm9ybXMoe1xuICAgICAgLy8gYXBwbHkgZ2FtbWEgdG8gb3BhY2l0eSB0byBtYWtlIGl0IHZpc3VhbGx5IFwibGluZWFyXCJcbiAgICAgIG9wYWNpdHk6IE1hdGgucG93KHRoaXMucHJvcHMub3BhY2l0eSwgMSAvIDIuMiksXG4gICAgICBPTkU6IDEuMFxuICAgIH0pO1xuICB9XG5cbiAgLy8gREVQUkVDQVRFRCBNRVRIT0RTXG5cbiAgLy8gVXBkYXRlcyBzZWxlY3RlZCBzdGF0ZSBtZW1iZXJzIGFuZCBtYXJrcyB0aGUgb2JqZWN0IGZvciByZWRyYXdcbiAgc2V0VW5pZm9ybXModW5pZm9ybU1hcCkge1xuICAgIGlmICh0aGlzLnN0YXRlLm1vZGVsKSB7XG4gICAgICB0aGlzLnN0YXRlLm1vZGVsLnNldFVuaWZvcm1zKHVuaWZvcm1NYXApO1xuICAgIH1cbiAgICAvLyBUT0RPIC0gc2V0IG5lZWRzUmVkcmF3IG9uIHRoZSBtb2RlbD9cbiAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICBsb2coMywgJ2xheWVyLnNldFVuaWZvcm1zJywgdW5pZm9ybU1hcCk7XG4gIH1cbn1cblxuTGF5ZXIubGF5ZXJOYW1lID0gJ0xheWVyJztcbkxheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuLy8gSEVMUEVSU1xuXG4vLyBDb25zdHJ1Y3RvcnMgaGF2ZSB0aGVpciBzdXBlciBjbGFzcyBjb25zdHJ1Y3RvcnMgYXMgcHJvdG90eXBlc1xuZnVuY3Rpb24gZ2V0T3duUHJvcGVydHkob2JqZWN0LCBwcm9wKSB7XG4gIHJldHVybiBvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgb2JqZWN0W3Byb3BdO1xufVxuLypcbiAqIFJldHVybiBtZXJnZWQgZGVmYXVsdCBwcm9wcyBzdG9yZWQgb24gbGF5ZXJzIGNvbnN0cnVjdG9yLCBjcmVhdGUgdGhlbSBpZiBuZWVkZWRcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKGxheWVyKSB7XG4gIGNvbnN0IG1lcmdlZERlZmF1bHRQcm9wcyA9IGdldE93blByb3BlcnR5KGxheWVyLmNvbnN0cnVjdG9yLCAnbWVyZ2VkRGVmYXVsdFByb3BzJyk7XG4gIGlmIChtZXJnZWREZWZhdWx0UHJvcHMpIHtcbiAgICByZXR1cm4gbWVyZ2VkRGVmYXVsdFByb3BzO1xuICB9XG4gIHJldHVybiBtZXJnZURlZmF1bHRQcm9wcyhsYXllcik7XG59XG5cbi8qXG4gKiBXYWxrIHRoZSBwcm90b3R5cGUgY2hhaW4gYW5kIG1lcmdlIGFsbCBkZWZhdWx0IHByb3BzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdFByb3BzKGxheWVyKSB7XG4gIGNvbnN0IHN1YkNsYXNzQ29uc3RydWN0b3IgPSBsYXllci5jb25zdHJ1Y3RvcjtcbiAgY29uc3QgbGF5ZXJOYW1lID0gZ2V0T3duUHJvcGVydHkoc3ViQ2xhc3NDb25zdHJ1Y3RvciwgJ2xheWVyTmFtZScpO1xuICBpZiAoIWxheWVyTmFtZSkge1xuICAgIGxvZy5vbmNlKDAsIGBsYXllciAke2xheWVyLmNvbnN0cnVjdG9yLm5hbWV9IGRvZXMgbm90IHNwZWNpZnkgYSBcImxheWVyTmFtZVwiYCk7XG4gIH1cbiAgbGV0IG1lcmdlZERlZmF1bHRQcm9wcyA9IHtcbiAgICBpZDogbGF5ZXJOYW1lIHx8IGxheWVyLmNvbnN0cnVjdG9yLm5hbWVcbiAgfTtcblxuICB3aGlsZSAobGF5ZXIpIHtcbiAgICBjb25zdCBsYXllckRlZmF1bHRQcm9wcyA9IGdldE93blByb3BlcnR5KGxheWVyLmNvbnN0cnVjdG9yLCAnZGVmYXVsdFByb3BzJyk7XG4gICAgT2JqZWN0LmZyZWV6ZShsYXllckRlZmF1bHRQcm9wcyk7XG4gICAgaWYgKGxheWVyRGVmYXVsdFByb3BzKSB7XG4gICAgICBtZXJnZWREZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBsYXllckRlZmF1bHRQcm9wcywgbWVyZ2VkRGVmYXVsdFByb3BzKTtcbiAgICB9XG4gICAgbGF5ZXIgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobGF5ZXIpO1xuICB9XG4gIC8vIFN0b3JlIGZvciBxdWljayBsb29rdXBcbiAgc3ViQ2xhc3NDb25zdHJ1Y3Rvci5tZXJnZWREZWZhdWx0UHJvcHMgPSBtZXJnZWREZWZhdWx0UHJvcHM7XG4gIHJldHVybiBtZXJnZWREZWZhdWx0UHJvcHM7XG59XG5cbmV4cG9ydCBjb25zdCBURVNUX0VYUE9SVFMgPSB7XG4gIG1lcmdlRGVmYXVsdFByb3BzXG59O1xuIl19