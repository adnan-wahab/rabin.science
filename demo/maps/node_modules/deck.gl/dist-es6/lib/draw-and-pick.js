// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */
import { GL, glContextWithState } from 'luma.gl';
import { getUniformsFromViewport } from './viewport-uniforms';
import { log, getBlendMode, setBlendMode } from './utils';

var EMPTY_PIXEL = new Uint8Array(4);
var renderCount = 0;

export function drawLayers(_ref) {
  var layers = _ref.layers,
      pass = _ref.pass;

  log.log(3, 'DRAWING ' + layers.length + ' layers');

  // render layers in normal colors
  var visibleCount = 0;
  // render layers in normal colors
  layers.forEach(function (layer, layerIndex) {
    if (!layer.isComposite && layer.props.visible) {
      layer.drawLayer({
        uniforms: Object.assign({ renderPickingBuffer: 0, pickingEnabled: 0 }, layer.context.uniforms, getUniformsFromViewport(layer.context.viewport, layer.props), { layerIndex: layerIndex })
      });
      visibleCount++;
    }
  });

  log.log(3, 'RENDER PASS ' + pass + ': ' + renderCount++ + '\n    ' + visibleCount + ' visible, ' + layers.length + ' total');
}

/* eslint-disable max-depth, max-statements */
export function pickLayers(gl, _ref2) {
  var layers = _ref2.layers,
      pickingFBO = _ref2.pickingFBO,
      _ref2$uniforms = _ref2.uniforms,
      uniforms = _ref2$uniforms === undefined ? {} : _ref2$uniforms,
      x = _ref2.x,
      y = _ref2.y,
      viewport = _ref2.viewport,
      mode = _ref2.mode,
      lastPickedInfo = _ref2.lastPickedInfo;


  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
  var deviceX = x * pixelRatio;
  var deviceY = gl.canvas.height - y * pixelRatio;

  // TODO - just return glContextWithState once luma updates
  var unhandledPickInfos = [];

  // Make sure we clear scissor test and fbo bindings in case of exceptions
  // We are only interested in one pixel, no need to render anything else
  glContextWithState(gl, {
    frameBuffer: pickingFBO,
    framebuffer: pickingFBO,
    scissorTest: { x: deviceX, y: deviceY, w: 1, h: 1 }
  }, function () {

    // Picking process start
    // Clear the frame buffer
    gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
    // Save current blend settings
    var oldBlendMode = getBlendMode(gl);
    // Set blend mode for picking
    // always overwrite existing pixel with [r,g,b,layerIndex]
    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO);
    gl.blendEquation(gl.FUNC_ADD);

    // Render all pickable layers in picking colors
    layers.forEach(function (layer, layerIndex) {
      if (!layer.isComposite && layer.props.visible && layer.props.pickable) {

        // Encode layerIndex with alpha
        gl.blendColor(0, 0, 0, (layerIndex + 1) / 255);

        layer.drawLayer({
          uniforms: Object.assign({ renderPickingBuffer: 1, pickingEnabled: 1 }, layer.context.uniforms, getUniformsFromViewport(layer.context.viewport, layer.props), { layerIndex: layerIndex })
        });
      }
    });

    // Read color in the central pixel, to be mapped with picking colors
    var pickedColor = new Uint8Array(4);
    gl.readPixels(deviceX, deviceY, 1, 1, GL.RGBA, GL.UNSIGNED_BYTE, pickedColor);

    // restore blend mode
    setBlendMode(gl, oldBlendMode);
    // Picking process end

    // Process picked info start
    // Decode picked color
    var pickedLayerIndex = pickedColor[3] - 1;
    var pickedLayer = pickedLayerIndex >= 0 ? layers[pickedLayerIndex] : null;
    var pickedObjectIndex = pickedLayer ? pickedLayer.decodePickingColor(pickedColor) : -1;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;
    var affectedLayers = pickedLayer ? [pickedLayer] : [];

    if (mode === 'hover') {
      // only invoke onHover events if picked object has changed
      var lastPickedObjectIndex = lastPickedInfo.index;
      var lastPickedLayerId = lastPickedInfo.layerId;

      if (pickedLayerId === lastPickedLayerId && pickedObjectIndex === lastPickedObjectIndex) {
        // picked object did not change, no need to proceed
        return;
      }

      if (pickedLayerId !== lastPickedLayerId) {
        // We cannot store a ref to lastPickedLayer in the context because
        // the state of an outdated layer is no longer valid
        // and the props may have changed
        var lastPickedLayer = layers.find(function (l) {
          return l.props.id === lastPickedLayerId;
        });
        if (lastPickedLayer) {
          // Let leave event fire before enter event
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      // Update layer manager context
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
    }

    var baseInfo = createInfo([x, y], viewport);
    baseInfo.devicePixel = [deviceX, deviceY];
    baseInfo.pixelRatio = pixelRatio;

    // Use a Map to store all picking infos.
    // The following two forEach loops are the result of
    // https://github.com/uber/deck.gl/issues/443
    // Please be very careful when changing this pattern
    var infos = new Map();

    affectedLayers.forEach(function (layer) {
      var info = Object.assign({}, baseInfo);

      if (layer === pickedLayer) {
        info.color = pickedColor;
        info.index = pickedObjectIndex;
        info.picked = true;
      }

      // Walk up the composite chain and find the owner of the event
      // sublayers are never directly exposed to the user
      while (layer && info) {
        // For a composite layer, sourceLayer will point to the sublayer
        // where the event originates from.
        // It provides additional context for the composite layer's
        // getPickingInfo() method to populate the info object
        var sourceLayer = info.layer || layer;
        info.layer = layer;
        // layer.pickLayer() function requires a non-null ```layer.state```
        // object to funtion properly. So the layer refereced here
        // must be the "current" layer, not an "out-dated" / "invalidated" layer
        info = layer.pickLayer({ info: info, mode: mode, sourceLayer: sourceLayer });
        layer = layer.parentLayer;
      }

      // This guarantees that there will be only one copy of info for
      // one composite layer
      if (info) {
        infos.set(info.layer.id, info);
      }
    });

    infos.forEach(function (info) {
      var handled = false;
      // The onClick and onHover functions are provided by the user
      // and out of control by deck.gl. It's very much possible that
      // the user calls React lifecycle methods in these function, such as
      // ReactComponent.setState(). React lifecycle methods sometimes induce
      // a re-render and re-generation of props of deck.gl and its layers,
      // which invalidates all layers currently passed to this very function.

      // Therefore, calls to functions like onClick and onHover need to be done
      // at the end of the function. NO operation relies on the states of current
      // layers should be called after this two lines of code.
      switch (mode) {
        case 'click':
          handled = info.layer.props.onClick(info);break;
        case 'hover':
          handled = info.layer.props.onHover(info);break;
        default:
          throw new Error('unknown pick type');
      }

      if (!handled) {
        unhandledPickInfos.push(info);
      }
    });
  });

  return unhandledPickInfos;
}
/* eslint-enable max-depth, max-statements */

function createInfo(pixel, viewport) {
  // Assign a number of potentially useful props to the "info" object
  return {
    color: EMPTY_PIXEL,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    lngLat: viewport.unproject(pixel)
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvZHJhdy1hbmQtcGljay5qcyJdLCJuYW1lcyI6WyJHTCIsImdsQ29udGV4dFdpdGhTdGF0ZSIsImdldFVuaWZvcm1zRnJvbVZpZXdwb3J0IiwibG9nIiwiZ2V0QmxlbmRNb2RlIiwic2V0QmxlbmRNb2RlIiwiRU1QVFlfUElYRUwiLCJVaW50OEFycmF5IiwicmVuZGVyQ291bnQiLCJkcmF3TGF5ZXJzIiwibGF5ZXJzIiwicGFzcyIsImxlbmd0aCIsInZpc2libGVDb3VudCIsImZvckVhY2giLCJsYXllciIsImxheWVySW5kZXgiLCJpc0NvbXBvc2l0ZSIsInByb3BzIiwidmlzaWJsZSIsImRyYXdMYXllciIsInVuaWZvcm1zIiwiT2JqZWN0IiwiYXNzaWduIiwicmVuZGVyUGlja2luZ0J1ZmZlciIsInBpY2tpbmdFbmFibGVkIiwiY29udGV4dCIsInZpZXdwb3J0IiwicGlja0xheWVycyIsImdsIiwicGlja2luZ0ZCTyIsIngiLCJ5IiwibW9kZSIsImxhc3RQaWNrZWRJbmZvIiwicGl4ZWxSYXRpbyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJkZXZpY2VYIiwiZGV2aWNlWSIsImNhbnZhcyIsImhlaWdodCIsInVuaGFuZGxlZFBpY2tJbmZvcyIsImZyYW1lQnVmZmVyIiwiZnJhbWVidWZmZXIiLCJzY2lzc29yVGVzdCIsInciLCJoIiwiY2xlYXIiLCJDT0xPUl9CVUZGRVJfQklUIiwiREVQVEhfQlVGRkVSX0JJVCIsIm9sZEJsZW5kTW9kZSIsImVuYWJsZSIsIkJMRU5EIiwiYmxlbmRGdW5jU2VwYXJhdGUiLCJPTkUiLCJaRVJPIiwiQ09OU1RBTlRfQUxQSEEiLCJibGVuZEVxdWF0aW9uIiwiRlVOQ19BREQiLCJwaWNrYWJsZSIsImJsZW5kQ29sb3IiLCJwaWNrZWRDb2xvciIsInJlYWRQaXhlbHMiLCJSR0JBIiwiVU5TSUdORURfQllURSIsInBpY2tlZExheWVySW5kZXgiLCJwaWNrZWRMYXllciIsInBpY2tlZE9iamVjdEluZGV4IiwiZGVjb2RlUGlja2luZ0NvbG9yIiwicGlja2VkTGF5ZXJJZCIsImlkIiwiYWZmZWN0ZWRMYXllcnMiLCJsYXN0UGlja2VkT2JqZWN0SW5kZXgiLCJpbmRleCIsImxhc3RQaWNrZWRMYXllcklkIiwibGF5ZXJJZCIsImxhc3RQaWNrZWRMYXllciIsImZpbmQiLCJsIiwidW5zaGlmdCIsImJhc2VJbmZvIiwiY3JlYXRlSW5mbyIsImRldmljZVBpeGVsIiwiaW5mb3MiLCJNYXAiLCJpbmZvIiwiY29sb3IiLCJwaWNrZWQiLCJzb3VyY2VMYXllciIsInBpY2tMYXllciIsInBhcmVudExheWVyIiwic2V0IiwiaGFuZGxlZCIsIm9uQ2xpY2siLCJvbkhvdmVyIiwiRXJyb3IiLCJwdXNoIiwicGl4ZWwiLCJsbmdMYXQiLCJ1bnByb2plY3QiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUUEsRUFBUixFQUFZQyxrQkFBWixRQUFxQyxTQUFyQztBQUNBLFNBQVFDLHVCQUFSLFFBQXNDLHFCQUF0QztBQUNBLFNBQVFDLEdBQVIsRUFBYUMsWUFBYixFQUEyQkMsWUFBM0IsUUFBOEMsU0FBOUM7O0FBRUEsSUFBTUMsY0FBYyxJQUFJQyxVQUFKLENBQWUsQ0FBZixDQUFwQjtBQUNBLElBQUlDLGNBQWMsQ0FBbEI7O0FBRUEsT0FBTyxTQUFTQyxVQUFULE9BQW9DO0FBQUEsTUFBZkMsTUFBZSxRQUFmQSxNQUFlO0FBQUEsTUFBUEMsSUFBTyxRQUFQQSxJQUFPOztBQUN6Q1IsTUFBSUEsR0FBSixDQUFRLENBQVIsZUFBc0JPLE9BQU9FLE1BQTdCOztBQUVBO0FBQ0EsTUFBSUMsZUFBZSxDQUFuQjtBQUNBO0FBQ0FILFNBQU9JLE9BQVAsQ0FBZSxVQUFDQyxLQUFELEVBQVFDLFVBQVIsRUFBdUI7QUFDcEMsUUFBSSxDQUFDRCxNQUFN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QkQ7O0FBZ0NBRixVQUFNdEUsT0FBTixDQUFjLGdCQUFRO0FBQ3BCLFVBQUkrRSxVQUFVLEtBQWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBUTVELElBQVI7QUFDQSxhQUFLLE9BQUw7QUFBYzRELG9CQUFVUCxLQUFLdkUsS0FBTCxDQUFXRyxLQUFYLENBQWlCNEUsT0FBakIsQ0FBeUJSLElBQXpCLENBQVYsQ0FBMEM7QUFDeEQsYUFBSyxPQUFMO0FBQWNPLG9CQUFVUCxLQUFLdkUsS0FBTCxDQUFXRyxLQUFYLENBQWlCNkUsT0FBakIsQ0FBeUJULElBQXpCLENBQVYsQ0FBMEM7QUFDeEQ7QUFBUyxnQkFBTSxJQUFJVSxLQUFKLENBQVUsbUJBQVYsQ0FBTjtBQUhUOztBQU1BLFVBQUksQ0FBQ0gsT0FBTCxFQUFjO0FBQ1puRCwyQkFBbUJ1RCxJQUFuQixDQUF3QlgsSUFBeEI7QUFDRDtBQUNGLEtBckJEO0FBc0JELEdBN0lEOztBQStJQSxTQUFPNUMsa0JBQVA7QUFDRDtBQUNEOztBQUVBLFNBQVN3QyxVQUFULENBQW9CZ0IsS0FBcEIsRUFBMkJ2RSxRQUEzQixFQUFxQztBQUNuQztBQUNBLFNBQU87QUFDTDRELFdBQU9qRixXQURGO0FBRUxvRSxXQUFPLENBQUMsQ0FGSDtBQUdMYyxZQUFRLEtBSEg7QUFJTHpELE9BQUdtRSxNQUFNLENBQU4sQ0FKRTtBQUtMbEUsT0FBR2tFLE1BQU0sQ0FBTixDQUxFO0FBTUxBLGdCQU5LO0FBT0xDLFlBQVF4RSxTQUFTeUUsU0FBVCxDQUFtQkYsS0FBbkI7QUFQSCxHQUFQO0FBU0QiLCJmaWxlIjoiZHJhdy1hbmQtcGljay5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQge0dMLCBnbENvbnRleHRXaXRoU3RhdGV9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydH0gZnJvbSAnLi92aWV3cG9ydC11bmlmb3Jtcyc7XG5pbXBvcnQge2xvZywgZ2V0QmxlbmRNb2RlLCBzZXRCbGVuZE1vZGV9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBFTVBUWV9QSVhFTCA9IG5ldyBVaW50OEFycmF5KDQpO1xubGV0IHJlbmRlckNvdW50ID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdMYXllcnMoe2xheWVycywgcGFzc30pIHtcbiAgbG9nLmxvZygzLCBgRFJBV0lORyAke2xheWVycy5sZW5ndGh9IGxheWVyc2ApO1xuXG4gIC8vIHJlbmRlciBsYXllcnMgaW4gbm9ybWFsIGNvbG9yc1xuICBsZXQgdmlzaWJsZUNvdW50ID0gMDtcbiAgLy8gcmVuZGVyIGxheWVycyBpbiBub3JtYWwgY29sb3JzXG4gIGxheWVycy5mb3JFYWNoKChsYXllciwgbGF5ZXJJbmRleCkgPT4ge1xuICAgIGlmICghbGF5ZXIuaXNDb21wb3NpdGUgJiYgbGF5ZXIucHJvcHMudmlzaWJsZSkge1xuICAgICAgbGF5ZXIuZHJhd0xheWVyKHtcbiAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge3JlbmRlclBpY2tpbmdCdWZmZXI6IDAsIHBpY2tpbmdFbmFibGVkOiAwfSxcbiAgICAgICAgICBsYXllci5jb250ZXh0LnVuaWZvcm1zLFxuICAgICAgICAgIGdldFVuaWZvcm1zRnJvbVZpZXdwb3J0KGxheWVyLmNvbnRleHQudmlld3BvcnQsIGxheWVyLnByb3BzKSxcbiAgICAgICAgICB7bGF5ZXJJbmRleH1cbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgICB2aXNpYmxlQ291bnQrKztcbiAgICB9XG4gIH0pO1xuXG4gIGxvZy5sb2coMywgYFJFTkRFUiBQQVNTICR7cGFzc306ICR7cmVuZGVyQ291bnQrK31cbiAgICAke3Zpc2libGVDb3VudH0gdmlzaWJsZSwgJHtsYXllcnMubGVuZ3RofSB0b3RhbGApO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGgsIG1heC1zdGF0ZW1lbnRzICovXG5leHBvcnQgZnVuY3Rpb24gcGlja0xheWVycyhnbCwge1xuICBsYXllcnMsXG4gIHBpY2tpbmdGQk8sXG4gIHVuaWZvcm1zID0ge30sXG4gIHgsXG4gIHksXG4gIHZpZXdwb3J0LFxuICBtb2RlLFxuICBsYXN0UGlja2VkSW5mb1xufSkge1xuXG4gIC8vIENvbnZlcnQgZnJvbSBjYW52YXMgdG9wLWxlZnQgdG8gV2ViR0wgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXNcbiAgLy8gQW5kIGNvbXBlbnNhdGUgZm9yIHBpeGVsUmF0aW9cbiAgY29uc3QgcGl4ZWxSYXRpbyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID9cbiAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gIGNvbnN0IGRldmljZVggPSB4ICogcGl4ZWxSYXRpbztcbiAgY29uc3QgZGV2aWNlWSA9IGdsLmNhbnZhcy5oZWlnaHQgLSB5ICogcGl4ZWxSYXRpbztcblxuICAvLyBUT0RPIC0ganVzdCByZXR1cm4gZ2xDb250ZXh0V2l0aFN0YXRlIG9uY2UgbHVtYSB1cGRhdGVzXG4gIGNvbnN0IHVuaGFuZGxlZFBpY2tJbmZvcyA9IFtdO1xuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBjbGVhciBzY2lzc29yIHRlc3QgYW5kIGZibyBiaW5kaW5ncyBpbiBjYXNlIG9mIGV4Y2VwdGlvbnNcbiAgLy8gV2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBvbmUgcGl4ZWwsIG5vIG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nIGVsc2VcbiAgZ2xDb250ZXh0V2l0aFN0YXRlKGdsLCB7XG4gICAgZnJhbWVCdWZmZXI6IHBpY2tpbmdGQk8sXG4gICAgZnJhbWVidWZmZXI6IHBpY2tpbmdGQk8sXG4gICAgc2Npc3NvclRlc3Q6IHt4OiBkZXZpY2VYLCB5OiBkZXZpY2VZLCB3OiAxLCBoOiAxfVxuICB9LCAoKSA9PiB7XG5cbiAgICAvLyBQaWNraW5nIHByb2Nlc3Mgc3RhcnRcbiAgICAvLyBDbGVhciB0aGUgZnJhbWUgYnVmZmVyXG4gICAgZ2wuY2xlYXIoR0wuQ09MT1JfQlVGRkVSX0JJVCB8IEdMLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgIC8vIFNhdmUgY3VycmVudCBibGVuZCBzZXR0aW5nc1xuICAgIGNvbnN0IG9sZEJsZW5kTW9kZSA9IGdldEJsZW5kTW9kZShnbCk7XG4gICAgLy8gU2V0IGJsZW5kIG1vZGUgZm9yIHBpY2tpbmdcbiAgICAvLyBhbHdheXMgb3ZlcndyaXRlIGV4aXN0aW5nIHBpeGVsIHdpdGggW3IsZyxiLGxheWVySW5kZXhdXG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShnbC5PTkUsIGdsLlpFUk8sIGdsLkNPTlNUQU5UX0FMUEhBLCBnbC5aRVJPKTtcbiAgICBnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcblxuICAgIC8vIFJlbmRlciBhbGwgcGlja2FibGUgbGF5ZXJzIGluIHBpY2tpbmcgY29sb3JzXG4gICAgbGF5ZXJzLmZvckVhY2goKGxheWVyLCBsYXllckluZGV4KSA9PiB7XG4gICAgICBpZiAoIWxheWVyLmlzQ29tcG9zaXRlICYmIGxheWVyLnByb3BzLnZpc2libGUgJiYgbGF5ZXIucHJvcHMucGlja2FibGUpIHtcblxuICAgICAgICAvLyBFbmNvZGUgbGF5ZXJJbmRleCB3aXRoIGFscGhhXG4gICAgICAgIGdsLmJsZW5kQ29sb3IoMCwgMCwgMCwgKGxheWVySW5kZXggKyAxKSAvIDI1NSk7XG5cbiAgICAgICAgbGF5ZXIuZHJhd0xheWVyKHtcbiAgICAgICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHtyZW5kZXJQaWNraW5nQnVmZmVyOiAxLCBwaWNraW5nRW5hYmxlZDogMX0sXG4gICAgICAgICAgICBsYXllci5jb250ZXh0LnVuaWZvcm1zLFxuICAgICAgICAgICAgZ2V0VW5pZm9ybXNGcm9tVmlld3BvcnQobGF5ZXIuY29udGV4dC52aWV3cG9ydCwgbGF5ZXIucHJvcHMpLFxuICAgICAgICAgICAge2xheWVySW5kZXh9XG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlYWQgY29sb3IgaW4gdGhlIGNlbnRyYWwgcGl4ZWwsIHRvIGJlIG1hcHBlZCB3aXRoIHBpY2tpbmcgY29sb3JzXG4gICAgY29uc3QgcGlja2VkQ29sb3IgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBnbC5yZWFkUGl4ZWxzKGRldmljZVgsIGRldmljZVksIDEsIDEsIEdMLlJHQkEsIEdMLlVOU0lHTkVEX0JZVEUsIHBpY2tlZENvbG9yKTtcblxuICAgIC8vIHJlc3RvcmUgYmxlbmQgbW9kZVxuICAgIHNldEJsZW5kTW9kZShnbCwgb2xkQmxlbmRNb2RlKTtcbiAgICAvLyBQaWNraW5nIHByb2Nlc3MgZW5kXG5cbiAgICAvLyBQcm9jZXNzIHBpY2tlZCBpbmZvIHN0YXJ0XG4gICAgLy8gRGVjb2RlIHBpY2tlZCBjb2xvclxuICAgIGNvbnN0IHBpY2tlZExheWVySW5kZXggPSBwaWNrZWRDb2xvclszXSAtIDE7XG4gICAgY29uc3QgcGlja2VkTGF5ZXIgPSBwaWNrZWRMYXllckluZGV4ID49IDAgPyBsYXllcnNbcGlja2VkTGF5ZXJJbmRleF0gOiBudWxsO1xuICAgIGNvbnN0IHBpY2tlZE9iamVjdEluZGV4ID0gcGlja2VkTGF5ZXIgPyBwaWNrZWRMYXllci5kZWNvZGVQaWNraW5nQ29sb3IocGlja2VkQ29sb3IpIDogLTE7XG4gICAgY29uc3QgcGlja2VkTGF5ZXJJZCA9IHBpY2tlZExheWVyICYmIHBpY2tlZExheWVyLnByb3BzLmlkO1xuICAgIGNvbnN0IGFmZmVjdGVkTGF5ZXJzID0gcGlja2VkTGF5ZXIgPyBbcGlja2VkTGF5ZXJdIDogW107XG5cbiAgICBpZiAobW9kZSA9PT0gJ2hvdmVyJykge1xuICAgICAgLy8gb25seSBpbnZva2Ugb25Ib3ZlciBldmVudHMgaWYgcGlja2VkIG9iamVjdCBoYXMgY2hhbmdlZFxuICAgICAgY29uc3QgbGFzdFBpY2tlZE9iamVjdEluZGV4ID0gbGFzdFBpY2tlZEluZm8uaW5kZXg7XG4gICAgICBjb25zdCBsYXN0UGlja2VkTGF5ZXJJZCA9IGxhc3RQaWNrZWRJbmZvLmxheWVySWQ7XG5cbiAgICAgIGlmIChwaWNrZWRMYXllcklkID09PSBsYXN0UGlja2VkTGF5ZXJJZCAmJiBwaWNrZWRPYmplY3RJbmRleCA9PT0gbGFzdFBpY2tlZE9iamVjdEluZGV4KSB7XG4gICAgICAgIC8vIHBpY2tlZCBvYmplY3QgZGlkIG5vdCBjaGFuZ2UsIG5vIG5lZWQgdG8gcHJvY2VlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwaWNrZWRMYXllcklkICE9PSBsYXN0UGlja2VkTGF5ZXJJZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3Qgc3RvcmUgYSByZWYgdG8gbGFzdFBpY2tlZExheWVyIGluIHRoZSBjb250ZXh0IGJlY2F1c2VcbiAgICAgICAgLy8gdGhlIHN0YXRlIG9mIGFuIG91dGRhdGVkIGxheWVyIGlzIG5vIGxvbmdlciB2YWxpZFxuICAgICAgICAvLyBhbmQgdGhlIHByb3BzIG1heSBoYXZlIGNoYW5nZWRcbiAgICAgICAgY29uc3QgbGFzdFBpY2tlZExheWVyID0gbGF5ZXJzLmZpbmQobCA9PiBsLnByb3BzLmlkID09PSBsYXN0UGlja2VkTGF5ZXJJZCk7XG4gICAgICAgIGlmIChsYXN0UGlja2VkTGF5ZXIpIHtcbiAgICAgICAgICAvLyBMZXQgbGVhdmUgZXZlbnQgZmlyZSBiZWZvcmUgZW50ZXIgZXZlbnRcbiAgICAgICAgICBhZmZlY3RlZExheWVycy51bnNoaWZ0KGxhc3RQaWNrZWRMYXllcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGxheWVyIG1hbmFnZXIgY29udGV4dFxuICAgICAgbGFzdFBpY2tlZEluZm8ubGF5ZXJJZCA9IHBpY2tlZExheWVySWQ7XG4gICAgICBsYXN0UGlja2VkSW5mby5pbmRleCA9IHBpY2tlZE9iamVjdEluZGV4O1xuICAgIH1cblxuICAgIGNvbnN0IGJhc2VJbmZvID0gY3JlYXRlSW5mbyhbeCwgeV0sIHZpZXdwb3J0KTtcbiAgICBiYXNlSW5mby5kZXZpY2VQaXhlbCA9IFtkZXZpY2VYLCBkZXZpY2VZXTtcbiAgICBiYXNlSW5mby5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcblxuICAgIC8vIFVzZSBhIE1hcCB0byBzdG9yZSBhbGwgcGlja2luZyBpbmZvcy5cbiAgICAvLyBUaGUgZm9sbG93aW5nIHR3byBmb3JFYWNoIGxvb3BzIGFyZSB0aGUgcmVzdWx0IG9mXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ViZXIvZGVjay5nbC9pc3N1ZXMvNDQzXG4gICAgLy8gUGxlYXNlIGJlIHZlcnkgY2FyZWZ1bCB3aGVuIGNoYW5naW5nIHRoaXMgcGF0dGVyblxuICAgIGNvbnN0IGluZm9zID0gbmV3IE1hcCgpO1xuXG4gICAgYWZmZWN0ZWRMYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICBsZXQgaW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VJbmZvKTtcblxuICAgICAgaWYgKGxheWVyID09PSBwaWNrZWRMYXllcikge1xuICAgICAgICBpbmZvLmNvbG9yID0gcGlja2VkQ29sb3I7XG4gICAgICAgIGluZm8uaW5kZXggPSBwaWNrZWRPYmplY3RJbmRleDtcbiAgICAgICAgaW5mby5waWNrZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBXYWxrIHVwIHRoZSBjb21wb3NpdGUgY2hhaW4gYW5kIGZpbmQgdGhlIG93bmVyIG9mIHRoZSBldmVudFxuICAgICAgLy8gc3VibGF5ZXJzIGFyZSBuZXZlciBkaXJlY3RseSBleHBvc2VkIHRvIHRoZSB1c2VyXG4gICAgICB3aGlsZSAobGF5ZXIgJiYgaW5mbykge1xuICAgICAgICAvLyBGb3IgYSBjb21wb3NpdGUgbGF5ZXIsIHNvdXJjZUxheWVyIHdpbGwgcG9pbnQgdG8gdGhlIHN1YmxheWVyXG4gICAgICAgIC8vIHdoZXJlIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20uXG4gICAgICAgIC8vIEl0IHByb3ZpZGVzIGFkZGl0aW9uYWwgY29udGV4dCBmb3IgdGhlIGNvbXBvc2l0ZSBsYXllcidzXG4gICAgICAgIC8vIGdldFBpY2tpbmdJbmZvKCkgbWV0aG9kIHRvIHBvcHVsYXRlIHRoZSBpbmZvIG9iamVjdFxuICAgICAgICBjb25zdCBzb3VyY2VMYXllciA9IGluZm8ubGF5ZXIgfHwgbGF5ZXI7XG4gICAgICAgIGluZm8ubGF5ZXIgPSBsYXllcjtcbiAgICAgICAgLy8gbGF5ZXIucGlja0xheWVyKCkgZnVuY3Rpb24gcmVxdWlyZXMgYSBub24tbnVsbCBgYGBsYXllci5zdGF0ZWBgYFxuICAgICAgICAvLyBvYmplY3QgdG8gZnVudGlvbiBwcm9wZXJseS4gU28gdGhlIGxheWVyIHJlZmVyZWNlZCBoZXJlXG4gICAgICAgIC8vIG11c3QgYmUgdGhlIFwiY3VycmVudFwiIGxheWVyLCBub3QgYW4gXCJvdXQtZGF0ZWRcIiAvIFwiaW52YWxpZGF0ZWRcIiBsYXllclxuICAgICAgICBpbmZvID0gbGF5ZXIucGlja0xheWVyKHtpbmZvLCBtb2RlLCBzb3VyY2VMYXllcn0pO1xuICAgICAgICBsYXllciA9IGxheWVyLnBhcmVudExheWVyO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIGNvcHkgb2YgaW5mbyBmb3JcbiAgICAgIC8vIG9uZSBjb21wb3NpdGUgbGF5ZXJcbiAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgIGluZm9zLnNldChpbmZvLmxheWVyLmlkLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGluZm9zLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgLy8gVGhlIG9uQ2xpY2sgYW5kIG9uSG92ZXIgZnVuY3Rpb25zIGFyZSBwcm92aWRlZCBieSB0aGUgdXNlclxuICAgICAgLy8gYW5kIG91dCBvZiBjb250cm9sIGJ5IGRlY2suZ2wuIEl0J3MgdmVyeSBtdWNoIHBvc3NpYmxlIHRoYXRcbiAgICAgIC8vIHRoZSB1c2VyIGNhbGxzIFJlYWN0IGxpZmVjeWNsZSBtZXRob2RzIGluIHRoZXNlIGZ1bmN0aW9uLCBzdWNoIGFzXG4gICAgICAvLyBSZWFjdENvbXBvbmVudC5zZXRTdGF0ZSgpLiBSZWFjdCBsaWZlY3ljbGUgbWV0aG9kcyBzb21ldGltZXMgaW5kdWNlXG4gICAgICAvLyBhIHJlLXJlbmRlciBhbmQgcmUtZ2VuZXJhdGlvbiBvZiBwcm9wcyBvZiBkZWNrLmdsIGFuZCBpdHMgbGF5ZXJzLFxuICAgICAgLy8gd2hpY2ggaW52YWxpZGF0ZXMgYWxsIGxheWVycyBjdXJyZW50bHkgcGFzc2VkIHRvIHRoaXMgdmVyeSBmdW5jdGlvbi5cblxuICAgICAgLy8gVGhlcmVmb3JlLCBjYWxscyB0byBmdW5jdGlvbnMgbGlrZSBvbkNsaWNrIGFuZCBvbkhvdmVyIG5lZWQgdG8gYmUgZG9uZVxuICAgICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb24uIE5PIG9wZXJhdGlvbiByZWxpZXMgb24gdGhlIHN0YXRlcyBvZiBjdXJyZW50XG4gICAgICAvLyBsYXllcnMgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGlzIHR3byBsaW5lcyBvZiBjb2RlLlxuICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlICdjbGljayc6IGhhbmRsZWQgPSBpbmZvLmxheWVyLnByb3BzLm9uQ2xpY2soaW5mbyk7IGJyZWFrO1xuICAgICAgY2FzZSAnaG92ZXInOiBoYW5kbGVkID0gaW5mby5sYXllci5wcm9wcy5vbkhvdmVyKGluZm8pOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBwaWNrIHR5cGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5kbGVkKSB7XG4gICAgICAgIHVuaGFuZGxlZFBpY2tJbmZvcy5wdXNoKGluZm8pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdW5oYW5kbGVkUGlja0luZm9zO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtZGVwdGgsIG1heC1zdGF0ZW1lbnRzICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUluZm8ocGl4ZWwsIHZpZXdwb3J0KSB7XG4gIC8vIEFzc2lnbiBhIG51bWJlciBvZiBwb3RlbnRpYWxseSB1c2VmdWwgcHJvcHMgdG8gdGhlIFwiaW5mb1wiIG9iamVjdFxuICByZXR1cm4ge1xuICAgIGNvbG9yOiBFTVBUWV9QSVhFTCxcbiAgICBpbmRleDogLTEsXG4gICAgcGlja2VkOiBmYWxzZSxcbiAgICB4OiBwaXhlbFswXSxcbiAgICB5OiBwaXhlbFsxXSxcbiAgICBwaXhlbCxcbiAgICBsbmdMYXQ6IHZpZXdwb3J0LnVucHJvamVjdChwaXhlbClcbiAgfTtcbn1cbiJdfQ==