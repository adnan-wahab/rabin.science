var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */
import { mat4, vec4 } from 'gl-matrix';
// import {Matrix4} from 'luma.gl';

import assert from 'assert';
import { COORDINATE_SYSTEM } from './constants';

function fp64ify(a) {
  var hiPart = Math.fround(a);
  var loPart = a - hiPart;
  return [hiPart, loPart];
}

// To quickly set a vector to zero
var ZERO_VECTOR = [0, 0, 0, 0];
// 4x4 matrix that drops 4th component of vector
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];

// The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,
// has lower performance but provides error checking.
// Uncomment when debugging
function calculateMatrixAndOffset(_ref) {
  var projectionMode = _ref.projectionMode,
      positionOrigin = _ref.positionOrigin,
      viewport = _ref.viewport,
      modelMatrix = _ref.modelMatrix;
  var viewMatrixUncentered = viewport.viewMatrixUncentered,
      viewMatrix = viewport.viewMatrix,
      projectionMatrix = viewport.projectionMatrix,
      viewProjectionMatrix = viewport.viewProjectionMatrix;


  var projectionCenter = void 0;
  var modelViewMatrix = void 0;

  switch (projectionMode) {

    case COORDINATE_SYSTEM.IDENTITY:
    case COORDINATE_SYSTEM.LNGLAT:
      projectionCenter = ZERO_VECTOR;
      // modelViewMatrix = new Matrix4(viewMatrix);
      modelViewMatrix = mat4.copy([], viewMatrix);
      break;

    // TODO: make lighitng work for meter offset mode
    case COORDINATE_SYSTEM.METER_OFFSETS:
      // Calculate transformed projectionCenter (in 64 bit precision)
      // This is the key to offset mode precision (avoids doing this
      // addition in 32 bit precision)
      var positionPixels = viewport.projectFlat(positionOrigin);
      // projectionCenter = new Matrix4(viewProjectionMatrix)
      //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);
      projectionCenter = vec4.transformMat4([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix);

      // Always apply uncentered projection matrix if available (shader adds center)
      // Zero out 4th coordinate ("after" model matrix) - avoids further translations
      // modelViewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)
      //   .multiplyRight(VECTOR_TO_POINT_MATRIX);
      modelViewMatrix = mat4.multiply([], viewMatrixUncentered || viewMatrix, VECTOR_TO_POINT_MATRIX);
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  var viewMatrixInv = mat4.invert([], modelViewMatrix) || modelViewMatrix;

  if (modelMatrix) {
    // Apply model matrix if supplied
    // modelViewMatrix.multiplyRight(modelMatrix);
    mat4.multiply(modelViewMatrix, modelViewMatrix, modelMatrix);
  }

  // const modelViewProjectionMatrix = new Matrix4(projectionMatrix).multiplyRight(modelViewMatrix);
  var modelViewProjectionMatrix = mat4.multiply([], projectionMatrix, modelViewMatrix);
  var cameraPos = [viewMatrixInv[12], viewMatrixInv[13], viewMatrixInv[14]];

  return {
    modelViewMatrix: modelViewMatrix,
    modelViewProjectionMatrix: modelViewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPos: cameraPos
  };
}

/**
 * Returns uniforms for shaders based on current projection
 * includes: projection matrix suitable for shaders
 *
 * TODO - Ensure this works with any viewport, not just WebMercatorViewports
 *
 * @param {WebMercatorViewport} viewport -
 * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
 */
export function getUniformsFromViewport(viewport) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$modelMatrix = _ref2.modelMatrix,
      modelMatrix = _ref2$modelMatrix === undefined ? null : _ref2$modelMatrix,
      _ref2$projectionMode = _ref2.projectionMode,
      projectionMode = _ref2$projectionMode === undefined ? COORDINATE_SYSTEM.LNGLAT : _ref2$projectionMode,
      _ref2$positionOrigin = _ref2.positionOrigin,
      positionOrigin = _ref2$positionOrigin === undefined ? [0, 0] : _ref2$positionOrigin;

  assert(viewport.scale, 'Viewport scale missing');

  var _calculateMatrixAndOf = calculateMatrixAndOffset({ projectionMode: projectionMode, positionOrigin: positionOrigin, modelMatrix: modelMatrix, viewport: viewport }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      modelViewMatrix = _calculateMatrixAndOf.modelViewMatrix,
      modelViewProjectionMatrix = _calculateMatrixAndOf.modelViewProjectionMatrix,
      cameraPos = _calculateMatrixAndOf.cameraPos;

  assert(modelViewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');

  // Calculate projection pixels per unit
  var projectionPixelsPerUnit = viewport.getDistanceScales().pixelsPerMeter;
  assert(projectionPixelsPerUnit, 'Viewport missing pixelsPerMeter');

  // calculate WebGL matrices

  // Convert to Float32
  var glProjectionMatrix = new Float32Array(modelViewProjectionMatrix);

  // "Float64Array"
  // Transpose the projection matrix to column major for GLSL.
  var glProjectionMatrixFP64 = new Float32Array(32);
  for (var i = 0; i < 4; ++i) {
    for (var j = 0; j < 4; ++j) {
      var _fp64ify = fp64ify(modelViewProjectionMatrix[j * 4 + i]);

      var _fp64ify2 = _slicedToArray(_fp64ify, 2);

      glProjectionMatrixFP64[(i * 4 + j) * 2] = _fp64ify2[0];
      glProjectionMatrixFP64[(i * 4 + j) * 2 + 1] = _fp64ify2[1];
    }
  }

  var devicePixelRatio = window && window.devicePixelRatio || 1;

  return {
    // Projection mode values
    projectionMode: projectionMode,
    projectionCenter: projectionCenter,

    // modelMatrix: modelMatrix || new Matrix4().identity(),
    modelViewMatrix: new Float32Array(modelViewMatrix),

    // Screen size
    viewportSize: [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio],
    devicePixelRatio: devicePixelRatio,

    // Main projection matrices
    projectionMatrix: glProjectionMatrix,
    projectionMatrixUncentered: glProjectionMatrix,
    projectionFP64: glProjectionMatrixFP64,
    projectionPixelsPerUnit: projectionPixelsPerUnit,

    // This is the mercator scale (2 ** zoom)
    projectionScale: viewport.scale,

    // Deprecated?
    projectionScaleFP64: fp64ify(viewport.scale),

    // This is for lighting calculations
    cameraPos: new Float32Array(cameraPos)

  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdmlld3BvcnQtdW5pZm9ybXMuanMiXSwibmFtZXMiOlsibWF0NCIsInZlYzQiLCJhc3NlcnQiLCJDT09SRElOQVRFX1NZU1RFTSIsImZwNjRpZnkiLCJhIiwiaGlQYXJ0IiwiTWF0aCIsImZyb3VuZCIsImxvUGFydCIsIlpFUk9fVkVDVE9SIiwiVkVDVE9SX1RPX1BPSU5UX01BVFJJWCIsImNhbGN1bGF0ZU1hdHJpeEFuZE9mZnNldCIsInByb2plY3Rpb25Nb2RlIiwicG9zaXRpb25PcmlnaW4iLCJ2aWV3cG9ydCIsIm1vZGVsTWF0cml4Iiwidmlld01hdHJpeFVuY2VudGVyZWQiLCJ2aWV3TWF0cml4IiwicHJvamVjdGlvbk1hdHJpeCIsInZpZXdQcm9qZWN0aW9uTWF0cml4IiwicHJvamVjdGlvbkNlbnRlciIsIm1vZGVsVmlld01hdHJpeCIsIklERU5USVRZIiwiTE5HTEFUIiwiY29weSIsIk1FVEVSX09GRlNFVFMiLCJwb3NpdGlvblBpeGVscyIsInByb2plY3RGbGF0IiwidHJhbnNmb3JtTWF0NCIsIm11bHRpcGx5IiwiRXJyb3IiLCJ2aWV3TWF0cml4SW52IiwiaW52ZXJ0IiwibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCIsImNhbWVyYVBvcyIsImdldFVuaWZvcm1zRnJvbVZpZXdwb3J0Iiwic2NhbGUiLCJwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdCIsImdldERpc3RhbmNlU2NhbGVzIiwicGl4ZWxzUGVyTWV0ZXIiLCJnbFByb2plY3Rpb25NYXRyaXgiLCJGbG9hdDMyQXJyYXkiLCJnbFByb2plY3Rpb25NYXRyaXhGUDY0IiwiaSIsImoiLCJkZXZpY2VQaXhlbFJhdGlvIiwid2luZG93Iiwidmlld3BvcnRTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJwcm9qZWN0aW9uTWF0cml4VW5jZW50ZXJlZCIsInByb2plY3Rpb25GUDY0IiwicHJvamVjdGlvblNjYWxlIiwicHJvamVjdGlvblNjYWxlRlA2NCJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVFBLElBQVIsRUFBY0MsSUFBZCxRQUF5QixXQUF6QjtBQUNBOztBQUVBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7QUFDQSxTQUFRQyxpQkFBUixRQUFnQyxhQUFoQzs7QUFFQSxTQUFTQyxPQUFULENBQWlCQyxDQUFqQixFQUFvQjtBQUNsQixNQUFNQyxTQUFTQyxLQUFLQyxNQUFMLENBQVlILENBQVosQ0FBZjtBQUNBLE1BQU1JLFNBQVNKLElBQUlDLE1BQW5CO0FBQ0EsU0FBTyxDQUFDQSxNQUFELEVBQVNHLE1BQVQsQ0FBUDtBQUNEOztBQUVEO0FBQ0EsSUFBTUMsY0FBYyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBcEI7QUFDQTtBQUNBLElBQU1DLHlCQUF5QixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLENBQXJDLEVBQXdDLENBQXhDLEVBQTJDLENBQTNDLEVBQThDLENBQTlDLENBQS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVNDLHdCQUFULE9BS0c7QUFBQSxNQUpEQyxjQUlDLFFBSkRBLGNBSUM7QUFBQSxNQUhEQyxjQUdDLFFBSERBLGNBR0M7QUFBQSxNQUZEQyxRQUVDLFFBRkRBLFFBRUM7QUFBQSxNQUREQyxXQUNDLFFBRERBLFdBQ0M7QUFBQSxNQUNNQyxvQkFETixHQUNrRkYsUUFEbEYsQ0FDTUUsb0JBRE47QUFBQSxNQUM0QkMsVUFENUIsR0FDa0ZILFFBRGxGLENBQzRCRyxVQUQ1QjtBQUFBLE1BQ3dDQyxnQkFEeEMsR0FDa0ZKLFFBRGxGLENBQ3dDSSxnQkFEeEM7QUFBQSxNQUMwREMsb0JBRDFELEdBQ2tGTCxRQURsRixDQUMwREssb0JBRDFEOzs7QUFHRCxNQUFJQyx5QkFBSjtBQUNBLE1BQUlDLHdCQUFKOztBQUVBLFVBQVFULGNBQVI7O0FBRUEsU0FBS1Ysa0JBQWtCb0IsUUFBdkI7QUFDQSxTQUFLcEIsa0JBQWtCcUIsTUFBdkI7QUFDRUgseUJBQW1CWCxXQUFuQjtBQUNBO0FBQ0FZLHdCQUFrQnRCLEtBQUt5QixJQUFMLENBQVUsRUFBVixFQUFjUCxVQUFkLENBQWxCO0FBQ0E7O0FBRUY7QUFDQSxTQUFLZixrQkFBa0J1QixhQUF2QjtBQUNFO0FBQ0E7QUFDQTtBQUNBLFVBQU1DLGlCQUFpQlosU0FBU2EsV0FBVCxDQUFxQmQsY0FBckIsQ0FBdkI7QUFDQTtBQUNBO0FBQ0FPLHlCQUFtQnBCLEtBQUs0QixhQUFMLENBQW1CLEVBQW5CLEVBQ2pCLENBQUNGLGVBQWUsQ0FBZixDQUFELEVBQW9CQSxlQUFlLENBQWYsQ0FBcEIsRUFBdUMsR0FBdkMsRUFBNEMsR0FBNUMsQ0FEaUIsRUFFakJQLG9CQUZpQixDQUFuQjs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBRSx3QkFBa0J0QixLQUFLOEIsUUFBTCxDQUFjLEVBQWQsRUFBa0JiLHdCQUF3QkMsVUFBMUMsRUFBc0RQLHNCQUF0RCxDQUFsQjtBQUNBOztBQUVGO0FBQ0UsWUFBTSxJQUFJb0IsS0FBSixDQUFVLHlCQUFWLENBQU47QUE3QkY7O0FBZ0NBLE1BQU1DLGdCQUFnQmhDLEtBQUtpQyxNQUFMLENBQVksRUFBWixFQUFnQlgsZUFBaEIsS0FBb0NBLGVBQTFEOztBQUVBLE1BQUlOLFdBQUosRUFBaUI7QUFDZjtBQUNBO0FBQ0FoQixTQUFLOEIsUUFBTCxDQUFjUixlQUFkLEVBQStCQSxlQUEvQixFQUFnRE4sV0FBaEQ7QUFDRDs7QUFFRDtBQUNBLE1BQU1rQiw0QkFBNEJsQyxLQUFLOEIsUUFBTCxDQUFjLEVBQWQsRUFBa0JYLGdCQUFsQixFQUFvQ0csZUFBcEMsQ0FBbEM7QUFDQSxNQUFNYSxZQUFZLENBQUNILGNBQWMsRUFBZCxDQUFELEVBQW9CQSxjQUFjLEVBQWQsQ0FBcEIsRUFBdUNBLGNBQWMsRUFBZCxDQUF2QyxDQUFsQjs7QUFFQSxTQUFPO0FBQ0xWLG9DQURLO0FBRUxZLHdEQUZLO0FBR0xiLHNDQUhLO0FBSUxjO0FBSkssR0FBUDtBQU1EOztBQUVEOzs7Ozs7Ozs7QUFTQSxPQUFPLFNBQVNDLHVCQUFULENBQWlDckIsUUFBakMsRUFJQztBQUFBLGtGQUFKLEVBQUk7QUFBQSxnQ0FITkMsV0FHTTtBQUFBLE1BSE5BLFdBR00scUNBSFEsSUFHUjtBQUFBLG1DQUZOSCxjQUVNO0FBQUEsTUFGTkEsY0FFTSx3Q0FGV1Ysa0JBQWtCcUIsTUFFN0I7QUFBQSxtQ0FETlYsY0FDTTtBQUFBLE1BRE5BLGNBQ00sd0NBRFcsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUNYOztBQUNOWixTQUFPYSxTQUFTc0IsS0FBaEIsRUFBdUIsd0JBQXZCOztBQURNLDhCQUlKekIseUJBQXlCLEVBQUNDLDhCQUFELEVBQWlCQyw4QkFBakIsRUFBaUNFLHdCQUFqQyxFQUE4Q0Qsa0JBQTlDLEVBQXpCLENBSkk7QUFBQSxNQUdDTSxnQkFIRCx5QkFHQ0EsZ0JBSEQ7QUFBQSxNQUdtQkMsZUFIbkIseUJBR21CQSxlQUhuQjtBQUFBLE1BR29DWSx5QkFIcEMseUJBR29DQSx5QkFIcEM7QUFBQSxNQUcrREMsU0FIL0QseUJBRytEQSxTQUgvRDs7QUFNTmpDLFNBQU9nQyx5QkFBUCxFQUFrQyw0Q0FBbEM7O0FBRUE7QUFDQSxNQUFNSSwwQkFBMEJ2QixTQUFTd0IsaUJBQVQsR0FBNkJDLGNBQTdEO0FBQ0F0QyxTQUFPb0MsdUJBQVAsRUFBZ0MsaUNBQWhDOztBQUVBOztBQUVBO0FBQ0EsTUFBTUcscUJBQXFCLElBQUlDLFlBQUosQ0FBaUJSLHlCQUFqQixDQUEzQjs7QUFFQTtBQUNBO0FBQ0EsTUFBTVMseUJBQXlCLElBQUlELFlBQUosQ0FBaUIsRUFBakIsQ0FBL0I7QUFDQSxPQUFLLElBQUlFLElBQUksQ0FBYixFQUFnQkEsSUFBSSxDQUFwQixFQUF1QixFQUFFQSxDQUF6QixFQUE0QjtBQUMxQixTQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSSxDQUFwQixFQUF1QixFQUFFQSxDQUF6QixFQUE0QjtBQUFBLHFCQUl0QnpDLFFBQVE4QiwwQkFBMEJXLElBQUksQ0FBSixHQUFRRCxDQUFsQyxDQUFSLENBSnNCOztBQUFBOztBQUV4QkQsNkJBQXVCLENBQUNDLElBQUksQ0FBSixHQUFRQyxDQUFULElBQWMsQ0FBckMsQ0FGd0I7QUFHeEJGLDZCQUF1QixDQUFDQyxJQUFJLENBQUosR0FBUUMsQ0FBVCxJQUFjLENBQWQsR0FBa0IsQ0FBekMsQ0FId0I7QUFLM0I7QUFDRjs7QUFFRCxNQUFNQyxtQkFBb0JDLFVBQVVBLE9BQU9ELGdCQUFsQixJQUF1QyxDQUFoRTs7QUFFQSxTQUFPO0FBQ0w7QUFDQWpDLGtDQUZLO0FBR0xRLHNDQUhLOztBQUtMO0FBQ0FDLHFCQUFpQixJQUFJb0IsWUFBSixDQUFpQnBCLGVBQWpCLENBTlo7O0FBUUw7QUFDQTBCLGtCQUFjLENBQUNqQyxTQUFTa0MsS0FBVCxHQUFpQkgsZ0JBQWxCLEVBQW9DL0IsU0FBU21DLE1BQVQsR0FBa0JKLGdCQUF0RCxDQVRUO0FBVUxBLHNDQVZLOztBQVlMO0FBQ0EzQixzQkFBa0JzQixrQkFiYjtBQWNMVSxnQ0FBNEJWLGtCQWR2QjtBQWVMVyxvQkFBZ0JULHNCQWZYO0FBZ0JMTCxvREFoQks7O0FBa0JMO0FBQ0FlLHFCQUFpQnRDLFNBQVNzQixLQW5CckI7O0FBcUJMO0FBQ0FpQix5QkFBcUJsRCxRQUFRVyxTQUFTc0IsS0FBakIsQ0F0QmhCOztBQXdCTDtBQUNBRixlQUFXLElBQUlPLFlBQUosQ0FBaUJQLFNBQWpCOztBQXpCTixHQUFQO0FBNEJEIiwiZmlsZSI6InZpZXdwb3J0LXVuaWZvcm1zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7bWF0NCwgdmVjNH0gZnJvbSAnZ2wtbWF0cml4Jztcbi8vIGltcG9ydCB7TWF0cml4NH0gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU19IGZyb20gJy4vY29uc3RhbnRzJztcblxuZnVuY3Rpb24gZnA2NGlmeShhKSB7XG4gIGNvbnN0IGhpUGFydCA9IE1hdGguZnJvdW5kKGEpO1xuICBjb25zdCBsb1BhcnQgPSBhIC0gaGlQYXJ0O1xuICByZXR1cm4gW2hpUGFydCwgbG9QYXJ0XTtcbn1cblxuLy8gVG8gcXVpY2tseSBzZXQgYSB2ZWN0b3IgdG8gemVyb1xuY29uc3QgWkVST19WRUNUT1IgPSBbMCwgMCwgMCwgMF07XG4vLyA0eDQgbWF0cml4IHRoYXQgZHJvcHMgNHRoIGNvbXBvbmVudCBvZiB2ZWN0b3JcbmNvbnN0IFZFQ1RPUl9UT19QT0lOVF9NQVRSSVggPSBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMF07XG5cbi8vIFRoZSBjb2RlIHRoYXQgdXRpbGl6ZXMgTWF0cml4NCBkb2VzIHRoZSBzYW1lIGNhbGN1bGF0aW9uIGFzIHRoZWlyIG1hdDQgY291bnRlcnBhcnRzLFxuLy8gaGFzIGxvd2VyIHBlcmZvcm1hbmNlIGJ1dCBwcm92aWRlcyBlcnJvciBjaGVja2luZy5cbi8vIFVuY29tbWVudCB3aGVuIGRlYnVnZ2luZ1xuZnVuY3Rpb24gY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0KHtcbiAgcHJvamVjdGlvbk1vZGUsXG4gIHBvc2l0aW9uT3JpZ2luLFxuICB2aWV3cG9ydCxcbiAgbW9kZWxNYXRyaXhcbn0pIHtcbiAgY29uc3Qge3ZpZXdNYXRyaXhVbmNlbnRlcmVkLCB2aWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4LCB2aWV3UHJvamVjdGlvbk1hdHJpeH0gPSB2aWV3cG9ydDtcblxuICBsZXQgcHJvamVjdGlvbkNlbnRlcjtcbiAgbGV0IG1vZGVsVmlld01hdHJpeDtcblxuICBzd2l0Y2ggKHByb2plY3Rpb25Nb2RlKSB7XG5cbiAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5JREVOVElUWTpcbiAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQ6XG4gICAgcHJvamVjdGlvbkNlbnRlciA9IFpFUk9fVkVDVE9SO1xuICAgIC8vIG1vZGVsVmlld01hdHJpeCA9IG5ldyBNYXRyaXg0KHZpZXdNYXRyaXgpO1xuICAgIG1vZGVsVmlld01hdHJpeCA9IG1hdDQuY29weShbXSwgdmlld01hdHJpeCk7XG4gICAgYnJlYWs7XG5cbiAgLy8gVE9ETzogbWFrZSBsaWdoaXRuZyB3b3JrIGZvciBtZXRlciBvZmZzZXQgbW9kZVxuICBjYXNlIENPT1JESU5BVEVfU1lTVEVNLk1FVEVSX09GRlNFVFM6XG4gICAgLy8gQ2FsY3VsYXRlIHRyYW5zZm9ybWVkIHByb2plY3Rpb25DZW50ZXIgKGluIDY0IGJpdCBwcmVjaXNpb24pXG4gICAgLy8gVGhpcyBpcyB0aGUga2V5IHRvIG9mZnNldCBtb2RlIHByZWNpc2lvbiAoYXZvaWRzIGRvaW5nIHRoaXNcbiAgICAvLyBhZGRpdGlvbiBpbiAzMiBiaXQgcHJlY2lzaW9uKVxuICAgIGNvbnN0IHBvc2l0aW9uUGl4ZWxzID0gdmlld3BvcnQucHJvamVjdEZsYXQocG9zaXRpb25PcmlnaW4pO1xuICAgIC8vIHByb2plY3Rpb25DZW50ZXIgPSBuZXcgTWF0cml4NCh2aWV3UHJvamVjdGlvbk1hdHJpeClcbiAgICAvLyAgIC50cmFuc2Zvcm1WZWN0b3IoW3Bvc2l0aW9uUGl4ZWxzWzBdLCBwb3NpdGlvblBpeGVsc1sxXSwgMC4wLCAxLjBdKTtcbiAgICBwcm9qZWN0aW9uQ2VudGVyID0gdmVjNC50cmFuc2Zvcm1NYXQ0KFtdLFxuICAgICAgW3Bvc2l0aW9uUGl4ZWxzWzBdLCBwb3NpdGlvblBpeGVsc1sxXSwgMC4wLCAxLjBdLFxuICAgICAgdmlld1Byb2plY3Rpb25NYXRyaXgpO1xuXG4gICAgLy8gQWx3YXlzIGFwcGx5IHVuY2VudGVyZWQgcHJvamVjdGlvbiBtYXRyaXggaWYgYXZhaWxhYmxlIChzaGFkZXIgYWRkcyBjZW50ZXIpXG4gICAgLy8gWmVybyBvdXQgNHRoIGNvb3JkaW5hdGUgKFwiYWZ0ZXJcIiBtb2RlbCBtYXRyaXgpIC0gYXZvaWRzIGZ1cnRoZXIgdHJhbnNsYXRpb25zXG4gICAgLy8gbW9kZWxWaWV3TWF0cml4ID0gbmV3IE1hdHJpeDQodmlld01hdHJpeFVuY2VudGVyZWQgfHwgdmlld01hdHJpeClcbiAgICAvLyAgIC5tdWx0aXBseVJpZ2h0KFZFQ1RPUl9UT19QT0lOVF9NQVRSSVgpO1xuICAgIG1vZGVsVmlld01hdHJpeCA9IG1hdDQubXVsdGlwbHkoW10sIHZpZXdNYXRyaXhVbmNlbnRlcmVkIHx8IHZpZXdNYXRyaXgsIFZFQ1RPUl9UT19QT0lOVF9NQVRSSVgpO1xuICAgIGJyZWFrO1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb2plY3Rpb24gbW9kZScpO1xuICB9XG5cbiAgY29uc3Qgdmlld01hdHJpeEludiA9IG1hdDQuaW52ZXJ0KFtdLCBtb2RlbFZpZXdNYXRyaXgpIHx8IG1vZGVsVmlld01hdHJpeDtcblxuICBpZiAobW9kZWxNYXRyaXgpIHtcbiAgICAvLyBBcHBseSBtb2RlbCBtYXRyaXggaWYgc3VwcGxpZWRcbiAgICAvLyBtb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlSaWdodChtb2RlbE1hdHJpeCk7XG4gICAgbWF0NC5tdWx0aXBseShtb2RlbFZpZXdNYXRyaXgsIG1vZGVsVmlld01hdHJpeCwgbW9kZWxNYXRyaXgpO1xuICB9XG5cbiAgLy8gY29uc3QgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KHByb2plY3Rpb25NYXRyaXgpLm11bHRpcGx5UmlnaHQobW9kZWxWaWV3TWF0cml4KTtcbiAgY29uc3QgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG1hdDQubXVsdGlwbHkoW10sIHByb2plY3Rpb25NYXRyaXgsIG1vZGVsVmlld01hdHJpeCk7XG4gIGNvbnN0IGNhbWVyYVBvcyA9IFt2aWV3TWF0cml4SW52WzEyXSwgdmlld01hdHJpeEludlsxM10sIHZpZXdNYXRyaXhJbnZbMTRdXTtcblxuICByZXR1cm4ge1xuICAgIG1vZGVsVmlld01hdHJpeCxcbiAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25DZW50ZXIsXG4gICAgY2FtZXJhUG9zXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB1bmlmb3JtcyBmb3Igc2hhZGVycyBiYXNlZCBvbiBjdXJyZW50IHByb2plY3Rpb25cbiAqIGluY2x1ZGVzOiBwcm9qZWN0aW9uIG1hdHJpeCBzdWl0YWJsZSBmb3Igc2hhZGVyc1xuICpcbiAqIFRPRE8gLSBFbnN1cmUgdGhpcyB3b3JrcyB3aXRoIGFueSB2aWV3cG9ydCwgbm90IGp1c3QgV2ViTWVyY2F0b3JWaWV3cG9ydHNcbiAqXG4gKiBAcGFyYW0ge1dlYk1lcmNhdG9yVmlld3BvcnR9IHZpZXdwb3J0IC1cbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gLSA0eDQgcHJvamVjdGlvbiBtYXRyaXggdGhhdCBjYW4gYmUgdXNlZCBpbiBzaGFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCh2aWV3cG9ydCwge1xuICBtb2RlbE1hdHJpeCA9IG51bGwsXG4gIHByb2plY3Rpb25Nb2RlID0gQ09PUkRJTkFURV9TWVNURU0uTE5HTEFULFxuICBwb3NpdGlvbk9yaWdpbiA9IFswLCAwXVxufSA9IHt9KSB7XG4gIGFzc2VydCh2aWV3cG9ydC5zY2FsZSwgJ1ZpZXdwb3J0IHNjYWxlIG1pc3NpbmcnKTtcblxuICBjb25zdCB7cHJvamVjdGlvbkNlbnRlciwgbW9kZWxWaWV3TWF0cml4LCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4LCBjYW1lcmFQb3N9ID1cbiAgICBjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQoe3Byb2plY3Rpb25Nb2RlLCBwb3NpdGlvbk9yaWdpbiwgbW9kZWxNYXRyaXgsIHZpZXdwb3J0fSk7XG5cbiAgYXNzZXJ0KG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsICdWaWV3cG9ydCBtaXNzaW5nIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgnKTtcblxuICAvLyBDYWxjdWxhdGUgcHJvamVjdGlvbiBwaXhlbHMgcGVyIHVuaXRcbiAgY29uc3QgcHJvamVjdGlvblBpeGVsc1BlclVuaXQgPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcygpLnBpeGVsc1Blck1ldGVyO1xuICBhc3NlcnQocHJvamVjdGlvblBpeGVsc1BlclVuaXQsICdWaWV3cG9ydCBtaXNzaW5nIHBpeGVsc1Blck1ldGVyJyk7XG5cbiAgLy8gY2FsY3VsYXRlIFdlYkdMIG1hdHJpY2VzXG5cbiAgLy8gQ29udmVydCB0byBGbG9hdDMyXG4gIGNvbnN0IGdsUHJvamVjdGlvbk1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgLy8gXCJGbG9hdDY0QXJyYXlcIlxuICAvLyBUcmFuc3Bvc2UgdGhlIHByb2plY3Rpb24gbWF0cml4IHRvIGNvbHVtbiBtYWpvciBmb3IgR0xTTC5cbiAgY29uc3QgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NCA9IG5ldyBGbG9hdDMyQXJyYXkoMzIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgKytqKSB7XG4gICAgICBbXG4gICAgICAgIGdsUHJvamVjdGlvbk1hdHJpeEZQNjRbKGkgKiA0ICsgaikgKiAyXSxcbiAgICAgICAgZ2xQcm9qZWN0aW9uTWF0cml4RlA2NFsoaSAqIDQgKyBqKSAqIDIgKyAxXVxuICAgICAgXSA9IGZwNjRpZnkobW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFtqICogNCArIGldKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gKHdpbmRvdyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMTtcblxuICByZXR1cm4ge1xuICAgIC8vIFByb2plY3Rpb24gbW9kZSB2YWx1ZXNcbiAgICBwcm9qZWN0aW9uTW9kZSxcbiAgICBwcm9qZWN0aW9uQ2VudGVyLFxuXG4gICAgLy8gbW9kZWxNYXRyaXg6IG1vZGVsTWF0cml4IHx8IG5ldyBNYXRyaXg0KCkuaWRlbnRpdHkoKSxcbiAgICBtb2RlbFZpZXdNYXRyaXg6IG5ldyBGbG9hdDMyQXJyYXkobW9kZWxWaWV3TWF0cml4KSxcblxuICAgIC8vIFNjcmVlbiBzaXplXG4gICAgdmlld3BvcnRTaXplOiBbdmlld3BvcnQud2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvLCB2aWV3cG9ydC5oZWlnaHQgKiBkZXZpY2VQaXhlbFJhdGlvXSxcbiAgICBkZXZpY2VQaXhlbFJhdGlvLFxuXG4gICAgLy8gTWFpbiBwcm9qZWN0aW9uIG1hdHJpY2VzXG4gICAgcHJvamVjdGlvbk1hdHJpeDogZ2xQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25NYXRyaXhVbmNlbnRlcmVkOiBnbFByb2plY3Rpb25NYXRyaXgsXG4gICAgcHJvamVjdGlvbkZQNjQ6IGdsUHJvamVjdGlvbk1hdHJpeEZQNjQsXG4gICAgcHJvamVjdGlvblBpeGVsc1BlclVuaXQsXG5cbiAgICAvLyBUaGlzIGlzIHRoZSBtZXJjYXRvciBzY2FsZSAoMiAqKiB6b29tKVxuICAgIHByb2plY3Rpb25TY2FsZTogdmlld3BvcnQuc2NhbGUsXG5cbiAgICAvLyBEZXByZWNhdGVkP1xuICAgIHByb2plY3Rpb25TY2FsZUZQNjQ6IGZwNjRpZnkodmlld3BvcnQuc2NhbGUpLFxuXG4gICAgLy8gVGhpcyBpcyBmb3IgbGlnaHRpbmcgY2FsY3VsYXRpb25zXG4gICAgY2FtZXJhUG9zOiBuZXcgRmxvYXQzMkFycmF5KGNhbWVyYVBvcylcblxuICB9O1xufVxuIl19