var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// IMLEMENTATION NOTES: Why new layers are created on every render
//
// The key here is to understand the declarative / functional
// programming nature of "reactive" applications.
//
// - In a reactive application, the entire "UI tree"
//   is re-rendered every time something in the application changes.
//
// - The UI framework (such as React or deck.gl) then diffs the rendered
//   tree of UI elements (React Elements or deck.gl Layers) against the
//   previously tree and makes optimized changes (to the DOM or to WebGL state).
//
// - Deck.gl layers are not based on React.
//   But it should be possible to wrap deck.gl layers in React components to
//   enable use of JSX.
//
// The deck.gl model that for the app creates a new set of on layers on every
// render.
// Internally, the new layers are efficiently matched against existing layers
// using layer ids.
//
// All calculated state (programs, attributes etc) are stored in a state object
// and this state object is moved forward to the match layer on every render
// cycle.  The new layer ends up with the state of the old layer (and the
// props of the new layer), while the old layer is simply discarded for
// garbage collecion.
//
/* eslint-disable no-try-catch */
import Layer from './layer';
import { log } from './utils';
import assert from 'assert';
import { drawLayers as _drawLayers, pickLayers } from './draw-and-pick';
import { LIFECYCLE } from './constants';
import { Viewport } from './viewports';

import { FramebufferObject } from 'luma.gl';

var LOG_PRIORITY_LIFECYCLE = 2;
var LOG_PRIORITY_LIFECYCLE_MINOR = 3;

var LayerManager = function () {
  function LayerManager(_ref) {
    var gl = _ref.gl;

    _classCallCheck(this, LayerManager);

    this.prevLayers = [];
    this.layers = [];
    // Tracks if any layers were drawn last update
    // Needed to ensure that screen is cleared when no layers are shown
    this.screenCleared = false;
    this.oldContext = {};
    this.context = {
      gl: gl,
      uniforms: {},
      viewport: null,
      viewportChanged: true,
      pickingFBO: null,
      lastPickedInfo: {
        index: -1,
        layerId: null
      }
    };
    Object.seal(this.context);
  }

  _createClass(LayerManager, [{
    key: 'setViewport',
    value: function setViewport(viewport) {
      assert(viewport instanceof Viewport, 'Invalid viewport');

      // TODO - viewport change detection breaks METER_OFFSETS mode
      // const oldViewport = this.context.viewport;
      // const viewportChanged = !oldViewport || !viewport.equals(oldViewport);

      var viewportChanged = true;

      if (viewportChanged) {
        Object.assign(this.oldContext, this.context);
        this.context.viewport = viewport;
        this.context.viewportChanged = true;
        this.context.uniforms = {};
        log(4, viewport);
      }

      return this;
    }
  }, {
    key: 'updateLayers',
    value: function updateLayers(_ref2) {
      var newLayers = _ref2.newLayers;

      /* eslint-disable */
      assert(this.context.viewport, 'LayerManager.updateLayers: viewport not set');

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return newLayer !== null;
      });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;

          layer.context = this.context;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.prevLayers = this.layers;

      var _updateLayers2 = this._updateLayers({
        oldLayers: this.prevLayers,
        newLayers: newLayers
      }),
          error = _updateLayers2.error,
          generatedLayers = _updateLayers2.generatedLayers;

      this.layers = generatedLayers;
      // Throw first error found, if any
      if (error) {
        throw error;
      }
      return this;
    }
  }, {
    key: 'drawLayers',
    value: function drawLayers(_ref3) {
      var pass = _ref3.pass;

      assert(this.context.viewport, 'LayerManager.drawLayers: viewport not set');

      _drawLayers({ layers: this.layers, pass: pass });

      return this;
    }
  }, {
    key: 'pickLayer',
    value: function pickLayer(_ref4) {
      var x = _ref4.x,
          y = _ref4.y,
          mode = _ref4.mode;
      var _context = this.context,
          gl = _context.gl,
          uniforms = _context.uniforms;

      // Set up a frame buffer if needed

      if (this.context.pickingFBO === null || gl.canvas.width !== this.context.pickingFBO.width || gl.canvas.height !== this.context.pickingFBO.height) {
        this.context.pickingFBO = new FramebufferObject(gl, {
          width: gl.canvas.width,
          height: gl.canvas.height
        });
      }
      return pickLayers(gl, {
        x: x,
        y: y,
        uniforms: {
          renderPickingBuffer: true,
          picking_uEnable: true
        },
        layers: this.layers,
        mode: mode,
        viewport: this.context.viewport,
        pickingFBO: this.context.pickingFBO,
        lastPickedInfo: this.context.lastPickedInfo
      });
    }
  }, {
    key: 'needsRedraw',
    value: function needsRedraw() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$clearRedrawFlag = _ref5.clearRedrawFlags,
          clearRedrawFlags = _ref5$clearRedrawFlag === undefined ? false : _ref5$clearRedrawFlag;

      if (!this.context.viewport) {
        return false;
      }

      var redraw = false;

      // Make sure that buffer is cleared once when layer list becomes empty
      if (this.layers.length === 0) {
        if (this.screenCleared === false) {
          redraw = true;
          this.screenCleared = true;
          return true;
        }
      } else {
        if (this.screenCleared === true) {
          this.screenCleared = false;
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var layer = _step2.value;

          redraw = redraw || layer.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return redraw;
    }

    // PRIVATE METHODS

    // Match all layers, checking for caught errors
    // To avoid having an exception in one layer disrupt other layers

  }, {
    key: '_updateLayers',
    value: function _updateLayers(_ref6) {
      var oldLayers = _ref6.oldLayers,
          newLayers = _ref6.newLayers;

      // Create old layer map
      var oldLayerMap = {};
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = oldLayers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var oldLayer = _step3.value;

          if (oldLayerMap[oldLayer.id]) {
            log.once(0, 'Multipe old layers with same id ' + layerName(oldLayer));
          } else {
            oldLayerMap[oldLayer.id] = oldLayer;
          }
        }

        // Allocate array for generated layers
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var generatedLayers = [];

      // Match sublayers
      var error = this._matchSublayers({
        newLayers: newLayers, oldLayerMap: oldLayerMap, generatedLayers: generatedLayers
      });

      var error2 = this._finalizeOldLayers(oldLayers);
      var firstError = error || error2;
      return { error: firstError, generatedLayers: generatedLayers };
    }

    /* eslint-disable max-statements */

  }, {
    key: '_matchSublayers',
    value: function _matchSublayers(_ref7) {
      var _this = this;

      var newLayers = _ref7.newLayers,
          oldLayerMap = _ref7.oldLayerMap,
          generatedLayers = _ref7.generatedLayers;

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return newLayer !== null;
      });

      var error = null;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        var _loop = function _loop() {
          var newLayer = _step4.value;

          newLayer.context = _this.context;

          try {
            // 1. given a new coming layer, find its matching layer
            var oldLayer = oldLayerMap[newLayer.id];
            oldLayerMap[newLayer.id] = null;

            if (oldLayer === null) {
              log.once(0, 'Multipe new layers with same id ' + layerName(newLayer));
            }

            // Only transfer state at this stage. We must not generate exceptions
            // until all layers' state have been transferred
            if (oldLayer) {
              log(LOG_PRIORITY_LIFECYCLE_MINOR, 'matched ' + layerName(newLayer), oldLayer, '=>', newLayer);
              _this._transferLayerState(oldLayer, newLayer);
              _this._updateLayer(newLayer);
            } else {
              _this._initializeNewLayer(newLayer);
            }
            generatedLayers.push(newLayer);

            // Call layer lifecycle method: render sublayers
            var sublayers = newLayer.isComposite ? newLayer.renderLayers() : null;
            // End layer lifecycle method: render sublayers

            if (sublayers) {
              sublayers = Array.isArray(sublayers) ? sublayers : [sublayers];

              // populate reference to parent layer
              sublayers.forEach(function (layer) {
                layer.parentLayer = newLayer;
              });

              _this._matchSublayers({
                newLayers: sublayers,
                oldLayerMap: oldLayerMap,
                generatedLayers: generatedLayers
              });
            }
          } catch (err) {
            log.once(0, 'deck.gl error during matching of ' + layerName(newLayer) + ' ' + err, err);
            // Save first error
            error = error || err;
          }
        };

        for (var _iterator4 = newLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return error;
    }
  }, {
    key: '_transferLayerState',
    value: function _transferLayerState(oldLayer, newLayer) {
      var state = oldLayer.state,
          props = oldLayer.props;

      // sanity check

      assert(state, 'deck.gl sanity check - Matching layer has no state');
      assert(oldLayer !== newLayer, 'deck.gl sanity check - Matching layer is same');

      // Move state
      newLayer.state = state;
      newLayer.lifecycle = LIFECYCLE.MATCHED;
      state.layer = newLayer;

      // Update model layer reference
      if (state.model) {
        state.model.userData.layer = newLayer;
      }
      // Keep a temporary ref to the old props, for prop comparison
      newLayer.oldProps = props;
      // oldLayer.state = null;
      oldLayer.lifecycle = LIFECYCLE.OUTDATED;
    }

    // Update the old layers that were not matched

  }, {
    key: '_finalizeOldLayers',
    value: function _finalizeOldLayers(oldLayers) {
      var error = null;
      // Matched layers have lifecycle state "outdated"
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = oldLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var layer = _step5.value;

          if (layer.lifecycle !== LIFECYCLE.OUTDATED) {
            error = error || this._finalizeLayer(layer);
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return error;
    }

    // Initializes a single layer, calling layer methods

  }, {
    key: '_initializeNewLayer',
    value: function _initializeNewLayer(layer) {
      var error = null;
      // Check if new layer, and initialize it's state
      if (!layer.state) {
        log(LOG_PRIORITY_LIFECYCLE, 'initializing ' + layerName(layer));
        try {
          layer.initializeLayer({
            oldProps: {},
            props: layer.props,
            oldContext: this.oldContext,
            context: this.context,
            changeFlags: layer.diffProps({}, layer.props, this.context)
          });
          layer.lifecycle = LIFECYCLE.INITIALIZED;
        } catch (err) {
          log.once(0, 'deck.gl error during initialization of ' + layerName(layer) + ' ' + err, err);
          // Save first error
          error = error || err;
        }
        // Set back pointer (used in picking)
        if (layer.state) {
          layer.state.layer = layer;
          // Save layer on model for picking purposes
          // TODO - store on model.userData rather than directly on model
        }
        if (layer.state && layer.state.model) {
          layer.state.model.userData.layer = layer;
        }
      }
      return error;
    }

    // Updates a single layer, calling layer methods

  }, {
    key: '_updateLayer',
    value: function _updateLayer(layer) {
      var oldProps = layer.oldProps,
          props = layer.props;

      var error = null;
      if (oldProps) {
        try {
          layer.updateLayer({
            oldProps: oldProps,
            props: props,
            context: this.context,
            oldContext: this.oldContext,
            changeFlags: layer.diffProps(oldProps, layer.props, this.context)
          });
        } catch (err) {
          log.once(0, 'deck.gl error during update of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        log(LOG_PRIORITY_LIFECYCLE_MINOR, 'updating ' + layerName(layer));
      }
      return error;
    }

    // Finalizes a single layer

  }, {
    key: '_finalizeLayer',
    value: function _finalizeLayer(layer) {
      var error = null;
      var state = layer.state;

      if (state) {
        try {
          layer.finalizeLayer();
        } catch (err) {
          log.once(0, 'deck.gl error during finalization of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        // layer.state = null;
        layer.lifecycle = LIFECYCLE.FINALIZED;
        log(LOG_PRIORITY_LIFECYCLE, 'finalizing ' + layerName(layer));
      }
      return error;
    }
  }]);

  return LayerManager;
}();

export default LayerManager;


function layerName(layer) {
  if (layer instanceof Layer) {
    return '' + layer;
  }
  return !layer ? 'null layer' : 'invalid layer';
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbGF5ZXItbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJMYXllciIsImxvZyIsImFzc2VydCIsImRyYXdMYXllcnMiLCJwaWNrTGF5ZXJzIiwiTElGRUNZQ0xFIiwiVmlld3BvcnQiLCJGcmFtZWJ1ZmZlck9iamVjdCIsIkxPR19QUklPUklUWV9MSUZFQ1lDTEUiLCJMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SIiwiTGF5ZXJNYW5hZ2VyIiwiZ2wiLCJwcmV2TGF5ZXJzIiwibGF5ZXJzIiwic2NyZWVuQ2xlYXJlZCIsIm9sZENvbnRleHQiLCJjb250ZXh0IiwidW5pZm9ybXMiLCJ2aWV3cG9ydCIsInZpZXdwb3J0Q2hhbmdlZCIsInBpY2tpbmdGQk8iLCJsYXN0UGlja2VkSW5mbyIsImluZGV4IiwibGF5ZXJJZCIsIk9iamVjdCIsInNlYWwiLCJhc3NpZ24iLCJuZXdMYXllcnMiLCJmaWx0ZXIiLCJuZXdMYXllciIsImxheWVyIiwiX3VwZGF0ZUxheWVycyIsIm9sZExheWVycyIsImVycm9yIiwiZ2VuZXJhdGVkTGF5ZXJzIiwicGFzcyIsIngiLCJ5IiwibW9kZSIsImNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0IiwicmVuZGVyUGlja2luZ0J1ZmZlciIsInBpY2tpbmdfdUVuYWJsZSIsImNsZWFyUmVkcmF3RmxhZ3MiLCJyZWRyYXciLCJsZW5ndGgiLCJnZXROZWVkc1JlZHJhdyIsIm9sZExheWVyTWFwIiwib2xkTGF5ZXIiLCJpZCIsIm9uY2UiLCJsYXllck5hbWUiLCJfbWF0Y2hTdWJsYXllcnMiLCJlcnJvcjIiLCJfZmluYWxpemVPbGRMYXllcnMiLCJmaXJzdEVycm9yIiwiX3RyYW5zZmVyTGF5ZXJTdGF0ZSIsIl91cGRhdGVMYXllciIsIl9pbml0aWFsaXplTmV3TGF5ZXIiLCJwdXNoIiwic3VibGF5ZXJzIiwiaXNDb21wb3NpdGUiLCJyZW5kZXJMYXllcnMiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwicGFyZW50TGF5ZXIiLCJlcnIiLCJzdGF0ZSIsInByb3BzIiwibGlmZWN5Y2xlIiwiTUFUQ0hFRCIsIm1vZGVsIiwidXNlckRhdGEiLCJvbGRQcm9wcyIsIk9VVERBVEVEIiwiX2ZpbmFsaXplTGF5ZXIiLCJpbml0aWFsaXplTGF5ZXIiLCJjaGFuZ2VGbGFncyIsImRpZmZQcm9wcyIsIklOSVRJQUxJWkVEIiwidXBkYXRlTGF5ZXIiLCJmaW5hbGl6ZUxheWVyIiwiRklOQUxJWkVEIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPQSxLQUFQLE1BQWtCLFNBQWxCO0FBQ0EsU0FBUUMsR0FBUixRQUFrQixTQUFsQjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7QUFDQSxTQUFRQyx5QkFBUixFQUFvQkMsVUFBcEIsUUFBcUMsaUJBQXJDO0FBQ0EsU0FBUUMsU0FBUixRQUF3QixhQUF4QjtBQUNBLFNBQVFDLFFBQVIsUUFBdUIsYUFBdkI7O0FBRUEsU0FBUUMsaUJBQVIsUUFBZ0MsU0FBaEM7O0FBRUEsSUFBTUMseUJBQXlCLENBQS9CO0FBQ0EsSUFBTUMsK0JBQStCLENBQXJDOztJQUVxQkMsWTtBQUNuQiw4QkFBa0I7QUFBQSxRQUFMQyxFQUFLLFFBQUxBLEVBQUs7O0FBQUE7O0FBQ2hCLFNBQUtDLFVBQUwsR0FBa0IsRUFBbEI7QUFDQSxTQUFLQyxNQUFMLEdBQWMsRUFBZDtBQUNBO0FBQ0E7QUFDQSxTQUFLQyxhQUFMLEdBQXFCLEtBQXJCO0FBQ0EsU0FBS0MsVUFBTCxHQUFrQixFQUFsQjtB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U0FGRCxDQUVFLE9BQU9mLEdBQVAsRUFBWTtBQUNabkUsY0FBSWtELElBQUosQ0FBUyxDQUFULDRDQUMwQ0MsVUFBVXRCLEtBQVYsQ0FEMUMsRUFDOERzQyxHQUQ5RDtBQUVBO0FBQ0FuQyxrQkFBUW1DLEdBQVI7QUFDRDtBQUNEO0FBQ0F0QyxjQUFNeUMsU0FBTixHQUFrQmxFLFVBQVUrRSxTQUE1QjtBQUNBbkYsWUFBSU8sc0JBQUosa0JBQTBDNEMsVUFBVXRCLEtBQVYsQ0FBMUM7QUFDRDtBQUNELGFBQU9HLEtBQVA7QUFDRDs7Ozs7O2VBcFVrQnZCLFk7OztBQXVVckIsU0FBUzBDLFNBQVQsQ0FBbUJ0QixLQUFuQixFQUEwQjtBQUN4QixNQUFJQSxpQkFBaUI5QixLQUFyQixFQUE0QjtBQUMxQixnQkFBVThCLEtBQVY7QUFDRDtBQUNELFNBQU8sQ0FBQ0EsS0FBRCxHQUFTLFlBQVQsR0FBd0IsZUFBL0I7QUFDRCIsImZpbGUiOiJsYXllci1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8vIElNTEVNRU5UQVRJT04gTk9URVM6IFdoeSBuZXcgbGF5ZXJzIGFyZSBjcmVhdGVkIG9uIGV2ZXJ5IHJlbmRlclxuLy9cbi8vIFRoZSBrZXkgaGVyZSBpcyB0byB1bmRlcnN0YW5kIHRoZSBkZWNsYXJhdGl2ZSAvIGZ1bmN0aW9uYWxcbi8vIHByb2dyYW1taW5nIG5hdHVyZSBvZiBcInJlYWN0aXZlXCIgYXBwbGljYXRpb25zLlxuLy9cbi8vIC0gSW4gYSByZWFjdGl2ZSBhcHBsaWNhdGlvbiwgdGhlIGVudGlyZSBcIlVJIHRyZWVcIlxuLy8gICBpcyByZS1yZW5kZXJlZCBldmVyeSB0aW1lIHNvbWV0aGluZyBpbiB0aGUgYXBwbGljYXRpb24gY2hhbmdlcy5cbi8vXG4vLyAtIFRoZSBVSSBmcmFtZXdvcmsgKHN1Y2ggYXMgUmVhY3Qgb3IgZGVjay5nbCkgdGhlbiBkaWZmcyB0aGUgcmVuZGVyZWRcbi8vICAgdHJlZSBvZiBVSSBlbGVtZW50cyAoUmVhY3QgRWxlbWVudHMgb3IgZGVjay5nbCBMYXllcnMpIGFnYWluc3QgdGhlXG4vLyAgIHByZXZpb3VzbHkgdHJlZSBhbmQgbWFrZXMgb3B0aW1pemVkIGNoYW5nZXMgKHRvIHRoZSBET00gb3IgdG8gV2ViR0wgc3RhdGUpLlxuLy9cbi8vIC0gRGVjay5nbCBsYXllcnMgYXJlIG5vdCBiYXNlZCBvbiBSZWFjdC5cbi8vICAgQnV0IGl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byB3cmFwIGRlY2suZ2wgbGF5ZXJzIGluIFJlYWN0IGNvbXBvbmVudHMgdG9cbi8vICAgZW5hYmxlIHVzZSBvZiBKU1guXG4vL1xuLy8gVGhlIGRlY2suZ2wgbW9kZWwgdGhhdCBmb3IgdGhlIGFwcCBjcmVhdGVzIGEgbmV3IHNldCBvZiBvbiBsYXllcnMgb24gZXZlcnlcbi8vIHJlbmRlci5cbi8vIEludGVybmFsbHksIHRoZSBuZXcgbGF5ZXJzIGFyZSBlZmZpY2llbnRseSBtYXRjaGVkIGFnYWluc3QgZXhpc3RpbmcgbGF5ZXJzXG4vLyB1c2luZyBsYXllciBpZHMuXG4vL1xuLy8gQWxsIGNhbGN1bGF0ZWQgc3RhdGUgKHByb2dyYW1zLCBhdHRyaWJ1dGVzIGV0YykgYXJlIHN0b3JlZCBpbiBhIHN0YXRlIG9iamVjdFxuLy8gYW5kIHRoaXMgc3RhdGUgb2JqZWN0IGlzIG1vdmVkIGZvcndhcmQgdG8gdGhlIG1hdGNoIGxheWVyIG9uIGV2ZXJ5IHJlbmRlclxuLy8gY3ljbGUuICBUaGUgbmV3IGxheWVyIGVuZHMgdXAgd2l0aCB0aGUgc3RhdGUgb2YgdGhlIG9sZCBsYXllciAoYW5kIHRoZVxuLy8gcHJvcHMgb2YgdGhlIG5ldyBsYXllciksIHdoaWxlIHRoZSBvbGQgbGF5ZXIgaXMgc2ltcGx5IGRpc2NhcmRlZCBmb3Jcbi8vIGdhcmJhZ2UgY29sbGVjaW9uLlxuLy9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXRyeS1jYXRjaCAqL1xuaW1wb3J0IExheWVyIGZyb20gJy4vbGF5ZXInO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHtkcmF3TGF5ZXJzLCBwaWNrTGF5ZXJzfSBmcm9tICcuL2RyYXctYW5kLXBpY2snO1xuaW1wb3J0IHtMSUZFQ1lDTEV9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7Vmlld3BvcnR9IGZyb20gJy4vdmlld3BvcnRzJztcblxuaW1wb3J0IHtGcmFtZWJ1ZmZlck9iamVjdH0gZnJvbSAnbHVtYS5nbCc7XG5cbmNvbnN0IExPR19QUklPUklUWV9MSUZFQ1lDTEUgPSAyO1xuY29uc3QgTE9HX1BSSU9SSVRZX0xJRkVDWUNMRV9NSU5PUiA9IDM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKHtnbH0pIHtcbiAgICB0aGlzLnByZXZMYXllcnMgPSBbXTtcbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIC8vIFRyYWNrcyBpZiBhbnkgbGF5ZXJzIHdlcmUgZHJhd24gbGFzdCB1cGRhdGVcbiAgICAvLyBOZWVkZWQgdG8gZW5zdXJlIHRoYXQgc2NyZWVuIGlzIGNsZWFyZWQgd2hlbiBubyBsYXllcnMgYXJlIHNob3duXG4gICAgdGhpcy5zY3JlZW5DbGVhcmVkID0gZmFsc2U7XG4gICAgdGhpcy5vbGRDb250ZXh0ID0ge307XG4gICAgdGhpcy5jb250ZXh0ID0ge1xuICAgICAgZ2wsXG4gICAgICB1bmlmb3Jtczoge30sXG4gICAgICB2aWV3cG9ydDogbnVsbCxcbiAgICAgIHZpZXdwb3J0Q2hhbmdlZDogdHJ1ZSxcbiAgICAgIHBpY2tpbmdGQk86IG51bGwsXG4gICAgICBsYXN0UGlja2VkSW5mbzoge1xuICAgICAgICBpbmRleDogLTEsXG4gICAgICAgIGxheWVySWQ6IG51bGxcbiAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5zZWFsKHRoaXMuY29udGV4dCk7XG4gIH1cblxuICBzZXRWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgIGFzc2VydCh2aWV3cG9ydCBpbnN0YW5jZW9mIFZpZXdwb3J0LCAnSW52YWxpZCB2aWV3cG9ydCcpO1xuXG4gICAgLy8gVE9ETyAtIHZpZXdwb3J0IGNoYW5nZSBkZXRlY3Rpb24gYnJlYWtzIE1FVEVSX09GRlNFVFMgbW9kZVxuICAgIC8vIGNvbnN0IG9sZFZpZXdwb3J0ID0gdGhpcy5jb250ZXh0LnZpZXdwb3J0O1xuICAgIC8vIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9ICFvbGRWaWV3cG9ydCB8fCAhdmlld3BvcnQuZXF1YWxzKG9sZFZpZXdwb3J0KTtcblxuICAgIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9IHRydWU7XG5cbiAgICBpZiAodmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMub2xkQ29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICAgIHRoaXMuY29udGV4dC52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgdGhpcy5jb250ZXh0LnZpZXdwb3J0Q2hhbmdlZCA9IHRydWU7XG4gICAgICB0aGlzLmNvbnRleHQudW5pZm9ybXMgPSB7fTtcbiAgICAgIGxvZyg0LCB2aWV3cG9ydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1cGRhdGVMYXllcnMoe25ld0xheWVyc30pIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgIGFzc2VydCh0aGlzLmNvbnRleHQudmlld3BvcnQsXG4gICAgICAnTGF5ZXJNYW5hZ2VyLnVwZGF0ZUxheWVyczogdmlld3BvcnQgbm90IHNldCcpO1xuXG4gICAgLy8gRmlsdGVyIG91dCBhbnkgbnVsbCBsYXllcnNcbiAgICBuZXdMYXllcnMgPSBuZXdMYXllcnMuZmlsdGVyKG5ld0xheWVyID0+IG5ld0xheWVyICE9PSBudWxsKTtcblxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgbmV3TGF5ZXJzKSB7XG4gICAgICBsYXllci5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIH1cblxuICAgIHRoaXMucHJldkxheWVycyA9IHRoaXMubGF5ZXJzO1xuICAgIGNvbnN0IHtlcnJvciwgZ2VuZXJhdGVkTGF5ZXJzfSA9IHRoaXMuX3VwZGF0ZUxheWVycyh7XG4gICAgICBvbGRMYXllcnM6IHRoaXMucHJldkxheWVycyxcbiAgICAgIG5ld0xheWVyc1xuICAgIH0pO1xuXG4gICAgdGhpcy5sYXllcnMgPSBnZW5lcmF0ZWRMYXllcnM7XG4gICAgLy8gVGhyb3cgZmlyc3QgZXJyb3IgZm91bmQsIGlmIGFueVxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZHJhd0xheWVycyh7cGFzc30pIHtcbiAgICBhc3NlcnQodGhpcy5jb250ZXh0LnZpZXdwb3J0LCAnTGF5ZXJNYW5hZ2VyLmRyYXdMYXllcnM6IHZpZXdwb3J0IG5vdCBzZXQnKTtcblxuICAgIGRyYXdMYXllcnMoe2xheWVyczogdGhpcy5sYXllcnMsIHBhc3N9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcGlja0xheWVyKHt4LCB5LCBtb2RlfSkge1xuICAgIGNvbnN0IHtnbCwgdW5pZm9ybXN9ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgLy8gU2V0IHVwIGEgZnJhbWUgYnVmZmVyIGlmIG5lZWRlZFxuICAgIGlmICh0aGlzLmNvbnRleHQucGlja2luZ0ZCTyA9PT0gbnVsbCB8fFxuICAgICAgZ2wuY2FudmFzLndpZHRoICE9PSB0aGlzLmNvbnRleHQucGlja2luZ0ZCTy53aWR0aCB8fFxuICAgICAgZ2wuY2FudmFzLmhlaWdodCAhPT0gdGhpcy5jb250ZXh0LnBpY2tpbmdGQk8uaGVpZ2h0KSB7XG4gICAgICB0aGlzLmNvbnRleHQucGlja2luZ0ZCTyA9IG5ldyBGcmFtZWJ1ZmZlck9iamVjdChnbCwge1xuICAgICAgICB3aWR0aDogZ2wuY2FudmFzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGdsLmNhbnZhcy5oZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGlja0xheWVycyhnbCwge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICByZW5kZXJQaWNraW5nQnVmZmVyOiB0cnVlLFxuICAgICAgICBwaWNraW5nX3VFbmFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBsYXllcnM6IHRoaXMubGF5ZXJzLFxuICAgICAgbW9kZSxcbiAgICAgIHZpZXdwb3J0OiB0aGlzLmNvbnRleHQudmlld3BvcnQsXG4gICAgICBwaWNraW5nRkJPOiB0aGlzLmNvbnRleHQucGlja2luZ0ZCTyxcbiAgICAgIGxhc3RQaWNrZWRJbmZvOiB0aGlzLmNvbnRleHQubGFzdFBpY2tlZEluZm9cbiAgICB9KTtcbiAgfVxuXG4gIG5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzID0gZmFsc2V9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuY29udGV4dC52aWV3cG9ydCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCByZWRyYXcgPSBmYWxzZTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpcyBjbGVhcmVkIG9uY2Ugd2hlbiBsYXllciBsaXN0IGJlY29tZXMgZW1wdHlcbiAgICBpZiAodGhpcy5sYXllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5zY3JlZW5DbGVhcmVkID09PSBmYWxzZSkge1xuICAgICAgICByZWRyYXcgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjcmVlbkNsZWFyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuc2NyZWVuQ2xlYXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNjcmVlbkNsZWFyZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XG4gICAgICByZWRyYXcgPSByZWRyYXcgfHwgbGF5ZXIuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZHJhdztcbiAgfVxuXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuXG4gIC8vIE1hdGNoIGFsbCBsYXllcnMsIGNoZWNraW5nIGZvciBjYXVnaHQgZXJyb3JzXG4gIC8vIFRvIGF2b2lkIGhhdmluZyBhbiBleGNlcHRpb24gaW4gb25lIGxheWVyIGRpc3J1cHQgb3RoZXIgbGF5ZXJzXG4gIF91cGRhdGVMYXllcnMoe29sZExheWVycywgbmV3TGF5ZXJzfSkge1xuICAgIC8vIENyZWF0ZSBvbGQgbGF5ZXIgbWFwXG4gICAgY29uc3Qgb2xkTGF5ZXJNYXAgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG9sZExheWVyIG9mIG9sZExheWVycykge1xuICAgICAgaWYgKG9sZExheWVyTWFwW29sZExheWVyLmlkXSkge1xuICAgICAgICBsb2cub25jZSgwLCBgTXVsdGlwZSBvbGQgbGF5ZXJzIHdpdGggc2FtZSBpZCAke2xheWVyTmFtZShvbGRMYXllcil9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGRMYXllck1hcFtvbGRMYXllci5pZF0gPSBvbGRMYXllcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGxvY2F0ZSBhcnJheSBmb3IgZ2VuZXJhdGVkIGxheWVyc1xuICAgIGNvbnN0IGdlbmVyYXRlZExheWVycyA9IFtdO1xuXG4gICAgLy8gTWF0Y2ggc3VibGF5ZXJzXG4gICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFN1YmxheWVycyh7XG4gICAgICBuZXdMYXllcnMsIG9sZExheWVyTWFwLCBnZW5lcmF0ZWRMYXllcnNcbiAgICB9KTtcblxuICAgIGNvbnN0IGVycm9yMiA9IHRoaXMuX2ZpbmFsaXplT2xkTGF5ZXJzKG9sZExheWVycyk7XG4gICAgY29uc3QgZmlyc3RFcnJvciA9IGVycm9yIHx8IGVycm9yMjtcbiAgICByZXR1cm4ge2Vycm9yOiBmaXJzdEVycm9yLCBnZW5lcmF0ZWRMYXllcnN9O1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgX21hdGNoU3VibGF5ZXJzKHtuZXdMYXllcnMsIG9sZExheWVyTWFwLCBnZW5lcmF0ZWRMYXllcnN9KSB7XG4gICAgLy8gRmlsdGVyIG91dCBhbnkgbnVsbCBsYXllcnNcbiAgICBuZXdMYXllcnMgPSBuZXdMYXllcnMuZmlsdGVyKG5ld0xheWVyID0+IG5ld0xheWVyICE9PSBudWxsKTtcblxuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgZm9yIChjb25zdCBuZXdMYXllciBvZiBuZXdMYXllcnMpIHtcbiAgICAgIG5ld0xheWVyLmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIDEuIGdpdmVuIGEgbmV3IGNvbWluZyBsYXllciwgZmluZCBpdHMgbWF0Y2hpbmcgbGF5ZXJcbiAgICAgICAgY29uc3Qgb2xkTGF5ZXIgPSBvbGRMYXllck1hcFtuZXdMYXllci5pZF07XG4gICAgICAgIG9sZExheWVyTWFwW25ld0xheWVyLmlkXSA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9sZExheWVyID09PSBudWxsKSB7XG4gICAgICAgICAgbG9nLm9uY2UoMCwgYE11bHRpcGUgbmV3IGxheWVycyB3aXRoIHNhbWUgaWQgJHtsYXllck5hbWUobmV3TGF5ZXIpfWApO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBPbmx5IHRyYW5zZmVyIHN0YXRlIGF0IHRoaXMgc3RhZ2UuIFdlIG11c3Qgbm90IGdlbmVyYXRlIGV4Y2VwdGlvbnNcbiAgICAgICAgLy8gdW50aWwgYWxsIGxheWVycycgc3RhdGUgaGF2ZSBiZWVuIHRyYW5zZmVycmVkXG4gICAgICAgIGlmIChvbGRMYXllcikge1xuICAgICAgICAgIGxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SLFxuICAgICAgICAgICAgYG1hdGNoZWQgJHtsYXllck5hbWUobmV3TGF5ZXIpfWAsIG9sZExheWVyLCAnPT4nLCBuZXdMYXllcik7XG4gICAgICAgICAgdGhpcy5fdHJhbnNmZXJMYXllclN0YXRlKG9sZExheWVyLCBuZXdMYXllcik7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlTGF5ZXIobmV3TGF5ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVOZXdMYXllcihuZXdMYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgZ2VuZXJhdGVkTGF5ZXJzLnB1c2gobmV3TGF5ZXIpO1xuXG4gICAgICAgIC8vIENhbGwgbGF5ZXIgbGlmZWN5Y2xlIG1ldGhvZDogcmVuZGVyIHN1YmxheWVyc1xuICAgICAgICBsZXQgc3VibGF5ZXJzID0gbmV3TGF5ZXIuaXNDb21wb3NpdGUgPyBuZXdMYXllci5yZW5kZXJMYXllcnMoKSA6IG51bGw7XG4gICAgICAgIC8vIEVuZCBsYXllciBsaWZlY3ljbGUgbWV0aG9kOiByZW5kZXIgc3VibGF5ZXJzXG5cbiAgICAgICAgaWYgKHN1YmxheWVycykge1xuICAgICAgICAgIHN1YmxheWVycyA9IEFycmF5LmlzQXJyYXkoc3VibGF5ZXJzKSA/IHN1YmxheWVycyA6IFtzdWJsYXllcnNdO1xuXG4gICAgICAgICAgLy8gcG9wdWxhdGUgcmVmZXJlbmNlIHRvIHBhcmVudCBsYXllclxuICAgICAgICAgIHN1YmxheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgICAgICAgIGxheWVyLnBhcmVudExheWVyID0gbmV3TGF5ZXI7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLl9tYXRjaFN1YmxheWVycyh7XG4gICAgICAgICAgICBuZXdMYXllcnM6IHN1YmxheWVycyxcbiAgICAgICAgICAgIG9sZExheWVyTWFwLFxuICAgICAgICAgICAgZ2VuZXJhdGVkTGF5ZXJzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLFxuICAgICAgICAgIGBkZWNrLmdsIGVycm9yIGR1cmluZyBtYXRjaGluZyBvZiAke2xheWVyTmFtZShuZXdMYXllcil9ICR7ZXJyfWAsIGVycik7XG4gICAgICAgIC8vIFNhdmUgZmlyc3QgZXJyb3JcbiAgICAgICAgZXJyb3IgPSBlcnJvciB8fCBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIF90cmFuc2ZlckxheWVyU3RhdGUob2xkTGF5ZXIsIG5ld0xheWVyKSB7XG4gICAgY29uc3Qge3N0YXRlLCBwcm9wc30gPSBvbGRMYXllcjtcblxuICAgIC8vIHNhbml0eSBjaGVja1xuICAgIGFzc2VydChzdGF0ZSwgJ2RlY2suZ2wgc2FuaXR5IGNoZWNrIC0gTWF0Y2hpbmcgbGF5ZXIgaGFzIG5vIHN0YXRlJyk7XG4gICAgYXNzZXJ0KG9sZExheWVyICE9PSBuZXdMYXllciwgJ2RlY2suZ2wgc2FuaXR5IGNoZWNrIC0gTWF0Y2hpbmcgbGF5ZXIgaXMgc2FtZScpO1xuXG4gICAgLy8gTW92ZSBzdGF0ZVxuICAgIG5ld0xheWVyLnN0YXRlID0gc3RhdGU7XG4gICAgbmV3TGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLk1BVENIRUQ7XG4gICAgc3RhdGUubGF5ZXIgPSBuZXdMYXllcjtcblxuICAgIC8vIFVwZGF0ZSBtb2RlbCBsYXllciByZWZlcmVuY2VcbiAgICBpZiAoc3RhdGUubW9kZWwpIHtcbiAgICAgIHN0YXRlLm1vZGVsLnVzZXJEYXRhLmxheWVyID0gbmV3TGF5ZXI7XG4gICAgfVxuICAgIC8vIEtlZXAgYSB0ZW1wb3JhcnkgcmVmIHRvIHRoZSBvbGQgcHJvcHMsIGZvciBwcm9wIGNvbXBhcmlzb25cbiAgICBuZXdMYXllci5vbGRQcm9wcyA9IHByb3BzO1xuICAgIC8vIG9sZExheWVyLnN0YXRlID0gbnVsbDtcbiAgICBvbGRMYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuT1VUREFURUQ7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIG9sZCBsYXllcnMgdGhhdCB3ZXJlIG5vdCBtYXRjaGVkXG4gIF9maW5hbGl6ZU9sZExheWVycyhvbGRMYXllcnMpIHtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIC8vIE1hdGNoZWQgbGF5ZXJzIGhhdmUgbGlmZWN5Y2xlIHN0YXRlIFwib3V0ZGF0ZWRcIlxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2Ygb2xkTGF5ZXJzKSB7XG4gICAgICBpZiAobGF5ZXIubGlmZWN5Y2xlICE9PSBMSUZFQ1lDTEUuT1VUREFURUQpIHtcbiAgICAgICAgZXJyb3IgPSBlcnJvciB8fCB0aGlzLl9maW5hbGl6ZUxheWVyKGxheWVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZXMgYSBzaW5nbGUgbGF5ZXIsIGNhbGxpbmcgbGF5ZXIgbWV0aG9kc1xuICBfaW5pdGlhbGl6ZU5ld0xheWVyKGxheWVyKSB7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAvLyBDaGVjayBpZiBuZXcgbGF5ZXIsIGFuZCBpbml0aWFsaXplIGl0J3Mgc3RhdGVcbiAgICBpZiAoIWxheWVyLnN0YXRlKSB7XG4gICAgICBsb2coTE9HX1BSSU9SSVRZX0xJRkVDWUNMRSwgYGluaXRpYWxpemluZyAke2xheWVyTmFtZShsYXllcil9YCk7XG4gICAgICB0cnkge1xuICAgICAgICBsYXllci5pbml0aWFsaXplTGF5ZXIoe1xuICAgICAgICAgIG9sZFByb3BzOiB7fSxcbiAgICAgICAgICBwcm9wczogbGF5ZXIucHJvcHMsXG4gICAgICAgICAgb2xkQ29udGV4dDogdGhpcy5vbGRDb250ZXh0LFxuICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBjaGFuZ2VGbGFnczogbGF5ZXIuZGlmZlByb3BzKHt9LCBsYXllci5wcm9wcywgdGhpcy5jb250ZXh0KVxuICAgICAgICB9KTtcbiAgICAgICAgbGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLklOSVRJQUxJWkVEO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsIGBkZWNrLmdsIGVycm9yIGR1cmluZyBpbml0aWFsaXphdGlvbiBvZiAke2xheWVyTmFtZShsYXllcil9ICR7ZXJyfWAsIGVycik7XG4gICAgICAgIC8vIFNhdmUgZmlyc3QgZXJyb3JcbiAgICAgICAgZXJyb3IgPSBlcnJvciB8fCBlcnI7XG4gICAgICB9XG4gICAgICAvLyBTZXQgYmFjayBwb2ludGVyICh1c2VkIGluIHBpY2tpbmcpXG4gICAgICBpZiAobGF5ZXIuc3RhdGUpIHtcbiAgICAgICAgbGF5ZXIuc3RhdGUubGF5ZXIgPSBsYXllcjtcbiAgICAgICAgLy8gU2F2ZSBsYXllciBvbiBtb2RlbCBmb3IgcGlja2luZyBwdXJwb3Nlc1xuICAgICAgICAvLyBUT0RPIC0gc3RvcmUgb24gbW9kZWwudXNlckRhdGEgcmF0aGVyIHRoYW4gZGlyZWN0bHkgb24gbW9kZWxcbiAgICAgIH1cbiAgICAgIGlmIChsYXllci5zdGF0ZSAmJiBsYXllci5zdGF0ZS5tb2RlbCkge1xuICAgICAgICBsYXllci5zdGF0ZS5tb2RlbC51c2VyRGF0YS5sYXllciA9IGxheWVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBVcGRhdGVzIGEgc2luZ2xlIGxheWVyLCBjYWxsaW5nIGxheWVyIG1ldGhvZHNcbiAgX3VwZGF0ZUxheWVyKGxheWVyKSB7XG4gICAgY29uc3Qge29sZFByb3BzLCBwcm9wc30gPSBsYXllcjtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGlmIChvbGRQcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGF5ZXIudXBkYXRlTGF5ZXIoe1xuICAgICAgICAgIG9sZFByb3BzLFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBvbGRDb250ZXh0OiB0aGlzLm9sZENvbnRleHQsXG4gICAgICAgICAgY2hhbmdlRmxhZ3M6IGxheWVyLmRpZmZQcm9wcyhvbGRQcm9wcywgbGF5ZXIucHJvcHMsIHRoaXMuY29udGV4dClcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLm9uY2UoMCwgYGRlY2suZ2wgZXJyb3IgZHVyaW5nIHVwZGF0ZSBvZiAke2xheWVyTmFtZShsYXllcil9YCwgZXJyKTtcbiAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgIH1cbiAgICAgIGxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SLCBgdXBkYXRpbmcgJHtsYXllck5hbWUobGF5ZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBGaW5hbGl6ZXMgYSBzaW5nbGUgbGF5ZXJcbiAgX2ZpbmFsaXplTGF5ZXIobGF5ZXIpIHtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGNvbnN0IHtzdGF0ZX0gPSBsYXllcjtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxheWVyLmZpbmFsaXplTGF5ZXIoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLFxuICAgICAgICAgIGBkZWNrLmdsIGVycm9yIGR1cmluZyBmaW5hbGl6YXRpb24gb2YgJHtsYXllck5hbWUobGF5ZXIpfWAsIGVycik7XG4gICAgICAgIC8vIFNhdmUgZmlyc3QgZXJyb3JcbiAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICB9XG4gICAgICAvLyBsYXllci5zdGF0ZSA9IG51bGw7XG4gICAgICBsYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuRklOQUxJWkVEO1xuICAgICAgbG9nKExPR19QUklPUklUWV9MSUZFQ1lDTEUsIGBmaW5hbGl6aW5nICR7bGF5ZXJOYW1lKGxheWVyKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxheWVyTmFtZShsYXllcikge1xuICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMYXllcikge1xuICAgIHJldHVybiBgJHtsYXllcn1gO1xuICB9XG4gIHJldHVybiAhbGF5ZXIgPyAnbnVsbCBsYXllcicgOiAnaW52YWxpZCBsYXllcic7XG59XG4iXX0=